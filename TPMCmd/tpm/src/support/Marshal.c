
// FILE GENERATED BY TpmExtractCode: DO NOT EDIT

#include "Tpm.h"
#if !TABLE_DRIVEN_MARSHAL
#  include "Marshal_fp.h"

// Table "Definition of Base Types" (Part 2: Structures)
//   UINT8 definition
TPM_RC
UINT8_Unmarshal(UINT8* target, BYTE** buffer, INT32* size)
{
    if((*size -= 1) < 0)
        return TPM_RC_INSUFFICIENT;
    *target = BYTE_ARRAY_TO_UINT8(*buffer);
    *buffer += 1;
    return TPM_RC_SUCCESS;
}
UINT16
UINT8_Marshal(UINT8* source, BYTE** buffer, INT32* size)
{
    if(buffer != 0)
    {
        if((size == 0) || ((*size -= 1) >= 0))
        {
            UINT8_TO_BYTE_ARRAY(*source, *buffer);
            *buffer += 1;
        }
        pAssert_ZERO(size == 0 || (*size >= 0));
    }
    return (1);
}

//   UINT16 definition
TPM_RC
UINT16_Unmarshal(UINT16* target, BYTE** buffer, INT32* size)
{
    if((*size -= 2) < 0)
        return TPM_RC_INSUFFICIENT;
    *target = BYTE_ARRAY_TO_UINT16(*buffer);
    *buffer += 2;
    return TPM_RC_SUCCESS;
}
UINT16
UINT16_Marshal(UINT16* source, BYTE** buffer, INT32* size)
{
    if(buffer != 0)
    {
        if((size == 0) || ((*size -= 2) >= 0))
        {
            UINT16_TO_BYTE_ARRAY(*source, *buffer);
            *buffer += 2;
        }
        pAssert_ZERO(size == 0 || (*size >= 0));
    }
    return (2);
}

//   UINT32 definition
TPM_RC
UINT32_Unmarshal(UINT32* target, BYTE** buffer, INT32* size)
{
    if((*size -= 4) < 0)
        return TPM_RC_INSUFFICIENT;
    *target = BYTE_ARRAY_TO_UINT32(*buffer);
    *buffer += 4;
    return TPM_RC_SUCCESS;
}
UINT16
UINT32_Marshal(UINT32* source, BYTE** buffer, INT32* size)
{
    if(buffer != 0)
    {
        if((size == 0) || ((*size -= 4) >= 0))
        {
            UINT32_TO_BYTE_ARRAY(*source, *buffer);
            *buffer += 4;
        }
        pAssert_ZERO(size == 0 || (*size >= 0));
    }
    return (4);
}

//   UINT64 definition
TPM_RC
UINT64_Unmarshal(UINT64* target, BYTE** buffer, INT32* size)
{
    if((*size -= 8) < 0)
        return TPM_RC_INSUFFICIENT;
    *target = BYTE_ARRAY_TO_UINT64(*buffer);
    *buffer += 8;
    return TPM_RC_SUCCESS;
}
UINT16
UINT64_Marshal(UINT64* source, BYTE** buffer, INT32* size)
{
    if(buffer != 0)
    {
        if((size == 0) || ((*size -= 8) >= 0))
        {
            UINT64_TO_BYTE_ARRAY(*source, *buffer);
            *buffer += 8;
        }
        pAssert_ZERO(size == 0 || (*size >= 0));
    }
    return (8);
}

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPM_ECC_CURVE Constants" (Part 2: Structures)
#  if ALG_ECC
TPM_RC
TPM_ECC_CURVE_Unmarshal(TPM_ECC_CURVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ECC_NIST_P192
            case TPM_ECC_NIST_P192:
#    endif  // ECC_NIST_P192
#    if ECC_NIST_P224
            case TPM_ECC_NIST_P224:
#    endif  // ECC_NIST_P224
#    if ECC_NIST_P256
            case TPM_ECC_NIST_P256:
#    endif  // ECC_NIST_P256
#    if ECC_NIST_P384
            case TPM_ECC_NIST_P384:
#    endif  // ECC_NIST_P384
#    if ECC_NIST_P521
            case TPM_ECC_NIST_P521:
#    endif  // ECC_NIST_P521
#    if ECC_BN_P256
            case TPM_ECC_BN_P256:
#    endif  // ECC_BN_P256
#    if ECC_BN_P638
            case TPM_ECC_BN_P638:
#    endif  // ECC_BN_P638
#    if ECC_SM2_P256
            case TPM_ECC_SM2_P256:
#    endif  // ECC_SM2_P256
#    if ECC_BP_P256_R1
            case TPM_ECC_BP_P256_R1:
#    endif  // ECC_BP_P256_R1
#    if ECC_BP_P384_R1
            case TPM_ECC_BP_P384_R1:
#    endif  // ECC_BP_P384_R1
#    if ECC_BP_P512_R1
            case TPM_ECC_BP_P512_R1:
#    endif  // ECC_BP_P512_R1
#    if ECC_CURVE_25519
            case TPM_ECC_CURVE_25519:
#    endif  // ECC_CURVE_25519
#    if ECC_CURVE_448
            case TPM_ECC_CURVE_448:
#    endif  // ECC_CURVE_448
                break;
            default:
                result = TPM_RC_CURVE;
                break;
        }
    }
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPM_CLOCK_ADJUST Constants" (Part 2: Structures)
TPM_RC
TPM_CLOCK_ADJUST_Unmarshal(TPM_CLOCK_ADJUST* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = INT8_Unmarshal((INT8*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_CLOCK_COARSE_SLOWER:
            case TPM_CLOCK_MEDIUM_SLOWER:
            case TPM_CLOCK_FINE_SLOWER:
            case TPM_CLOCK_NO_CHANGE:
            case TPM_CLOCK_FINE_FASTER:
            case TPM_CLOCK_MEDIUM_FASTER:
            case TPM_CLOCK_COARSE_FASTER:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPM_EO Constants" (Part 2: Structures)
TPM_RC
TPM_EO_Unmarshal(TPM_EO* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_EO_EQ:
            case TPM_EO_NEQ:
            case TPM_EO_SIGNED_GT:
            case TPM_EO_UNSIGNED_GT:
            case TPM_EO_SIGNED_LT:
            case TPM_EO_UNSIGNED_LT:
            case TPM_EO_SIGNED_GE:
            case TPM_EO_UNSIGNED_GE:
            case TPM_EO_SIGNED_LE:
            case TPM_EO_UNSIGNED_LE:
            case TPM_EO_BITSET:
            case TPM_EO_BITCLEAR:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPM_SU Constants" (Part 2: Structures)
TPM_RC
TPM_SU_Unmarshal(TPM_SU* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_SU_CLEAR:
            case TPM_SU_STATE:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPM_SE Constants" (Part 2: Structures)
TPM_RC
TPM_SE_Unmarshal(TPM_SE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT8_Unmarshal((UINT8*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_SE_HMAC:
            case TPM_SE_POLICY:
            case TPM_SE_TRIAL:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPM_CAP Constants" (Part 2: Structures)
TPM_RC
TPM_CAP_Unmarshal(TPM_CAP* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_CAP_ALGS:
            case TPM_CAP_HANDLES:
            case TPM_CAP_COMMANDS:
            case TPM_CAP_PP_COMMANDS:
            case TPM_CAP_AUDIT_COMMANDS:
            case TPM_CAP_PCRS:
            case TPM_CAP_TPM_PROPERTIES:
            case TPM_CAP_PCR_PROPERTIES:
#  if ALG_ECC
            case TPM_CAP_ECC_CURVES:
#  endif  // ALG_ECC
            case TPM_CAP_AUTH_POLICIES:
            case TPM_CAP_ACT:
#  if SEC_CHANNEL_SUPPORT
            case TPM_CAP_PUB_KEYS:
            case TPM_CAP_SPDM_SESSION_INFO:
#  endif  // SEC_CHANNEL_SUPPORT
            case TPM_CAP_VENDOR_PROPERTY:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMA_ALGORITHM Bits" (Part 2: Structures)
TPM_RC
TPMA_ALGORITHM_Unmarshal(TPMA_ALGORITHM* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT32*)target) & (UINT32)0xfffff8f0)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMA_OBJECT Bits" (Part 2: Structures)
TPM_RC
TPMA_OBJECT_Unmarshal(TPMA_OBJECT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT32*)target) & (UINT32)0xfff0f001)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMA_SESSION Bits" (Part 2: Structures)
TPM_RC
TPMA_SESSION_Unmarshal(TPMA_SESSION* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT8_Unmarshal((UINT8*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT8*)target) & (UINT8)0x18)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMA_ACT Bits" (Part 2: Structures)
TPM_RC
TPMA_ACT_Unmarshal(TPMA_ACT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT32*)target) & (UINT32)0xfffffffc)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMI_YES_NO Type" (Part 2: Structures)
TPM_RC
TPMI_YES_NO_Unmarshal(TPMI_YES_NO* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = BYTE_Unmarshal((BYTE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case NO:
            case YES:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_DH_OBJECT Type" (Part 2: Structures)
TPM_RC
TPMI_DH_OBJECT_Unmarshal(
    TPMI_DH_OBJECT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS) && ((*target != TPM_RH_NULL) || !flag)
       && ((*target < TRANSIENT_FIRST) || (*target > TRANSIENT_LAST))
       && ((*target < PERSISTENT_FIRST) || (*target > PERSISTENT_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_DH_PARENT Type" (Part 2: Structures)
TPM_RC
TPMI_DH_PARENT_Unmarshal(TPMI_DH_PARENT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_FW_OWNER:
            case TPM_RH_FW_ENDORSEMENT:
            case TPM_RH_FW_PLATFORM:
                break;
            default:
                if((*target != TPM_RH_NULL) && (*target != TPM_RH_FW_NULL)
                   && ((*target < SVN_NULL_FIRST) || (*target > SVN_NULL_LAST))
                   && ((*target < SVN_OWNER_FIRST) || (*target > SVN_OWNER_LAST))
                   && ((*target < SVN_ENDORSEMENT_FIRST)
                       || (*target > SVN_ENDORSEMENT_LAST))
                   && ((*target < SVN_PLATFORM_FIRST)
                       || (*target > SVN_PLATFORM_LAST))
                   && ((*target < TRANSIENT_FIRST) || (*target > TRANSIENT_LAST))
                   && ((*target < PERSISTENT_FIRST) || (*target > PERSISTENT_LAST)))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_DH_PERSISTENT Type" (Part 2: Structures)
TPM_RC
TPMI_DH_PERSISTENT_Unmarshal(TPMI_DH_PERSISTENT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < PERSISTENT_FIRST) || (*target > PERSISTENT_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_DH_ENTITY Type" (Part 2: Structures)
TPM_RC
TPMI_DH_ENTITY_Unmarshal(
    TPMI_DH_ENTITY* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_LOCKOUT:
                break;
            default:
                if(((*target != TPM_RH_NULL) || !flag)
                   && ((*target < TRANSIENT_FIRST) || (*target > TRANSIENT_LAST))
                   && ((*target < PERSISTENT_FIRST) || (*target > PERSISTENT_LAST))
                   && ((*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST))
                   && (*target > PCR_LAST)
                   && ((*target < TPM_RH_AUTH_00) || (*target > TPM_RH_AUTH_FF)))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_DH_PCR Type" (Part 2: Structures)
TPM_RC
TPMI_DH_PCR_Unmarshal(TPMI_DH_PCR* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS) && ((*target != TPM_RH_NULL) || !flag)
       && (*target > PCR_LAST))
        result = TPM_RC_VALUE;
    return result;
}

// Table "Definition of TPMI_SH_AUTH_SESSION Type" (Part 2: Structures)
TPM_RC
TPMI_SH_AUTH_SESSION_Unmarshal(
    TPMI_SH_AUTH_SESSION* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS) && ((*target != TPM_RS_PW) || !flag)
       && ((*target < HMAC_SESSION_FIRST) || (*target > HMAC_SESSION_LAST))
       && ((*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_SH_HMAC Type" (Part 2: Structures)
TPM_RC
TPMI_SH_HMAC_Unmarshal(TPMI_SH_HMAC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < HMAC_SESSION_FIRST) || (*target > HMAC_SESSION_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_SH_POLICY Type" (Part 2: Structures)
TPM_RC
TPMI_SH_POLICY_Unmarshal(TPMI_SH_POLICY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_DH_CONTEXT Type" (Part 2: Structures)
TPM_RC
TPMI_DH_CONTEXT_Unmarshal(TPMI_DH_CONTEXT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < HMAC_SESSION_FIRST) || (*target > HMAC_SESSION_LAST))
       && ((*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST))
       && ((*target < TRANSIENT_FIRST) || (*target > TRANSIENT_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_DH_SAVED Type" (Part 2: Structures)
TPM_RC
TPMI_DH_SAVED_Unmarshal(TPMI_DH_SAVED* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case 0x80000000:
            case 0x80000001:
            case 0x80000002:
                break;
            default:
                if(((*target < HMAC_SESSION_FIRST) || (*target > HMAC_SESSION_LAST))
                   && ((*target < POLICY_SESSION_FIRST)
                       || (*target > POLICY_SESSION_LAST)))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_RH_HIERARCHY Type" (Part 2: Structures)
TPM_RC
TPMI_RH_HIERARCHY_Unmarshal(TPMI_RH_HIERARCHY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_FW_OWNER:
            case TPM_RH_FW_ENDORSEMENT:
            case TPM_RH_FW_PLATFORM:
                break;
            default:
                if((*target != TPM_RH_NULL) && (*target != TPM_RH_FW_NULL)
                   && ((*target < SVN_NULL_FIRST) || (*target > SVN_NULL_LAST))
                   && ((*target < SVN_OWNER_FIRST) || (*target > SVN_OWNER_LAST))
                   && ((*target < SVN_ENDORSEMENT_FIRST)
                       || (*target > SVN_ENDORSEMENT_LAST))
                   && ((*target < SVN_PLATFORM_FIRST)
                       || (*target > SVN_PLATFORM_LAST)))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_RH_ENABLES Type" (Part 2: Structures)
TPM_RC
TPMI_RH_ENABLES_Unmarshal(
    TPMI_RH_ENABLES* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_PLATFORM_NV:
                break;
            default:
                if((*target != TPM_RH_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_RH_HIERARCHY_AUTH Type" (Part 2: Structures)
TPM_RC
TPMI_RH_HIERARCHY_AUTH_Unmarshal(
    TPMI_RH_HIERARCHY_AUTH* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_LOCKOUT:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_HIERARCHY_POLICY Type" (Part 2: Structures)
TPM_RC
TPMI_RH_HIERARCHY_POLICY_Unmarshal(
    TPMI_RH_HIERARCHY_POLICY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
            case TPM_RH_LOCKOUT:
                break;
            default:
                if((*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_BASE_HIERARCHY Type" (Part 2: Structures)
TPM_RC
TPMI_RH_BASE_HIERARCHY_Unmarshal(
    TPMI_RH_BASE_HIERARCHY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_ENDORSEMENT:
            case TPM_RH_PLATFORM:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_RH_PLATFORM Type" (Part 2: Structures)
TPM_RC
TPMI_RH_PLATFORM_Unmarshal(TPMI_RH_PLATFORM* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_PLATFORM:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_OWNER Type" (Part 2: Structures)
TPM_RC
TPMI_RH_OWNER_Unmarshal(TPMI_RH_OWNER* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
                break;
            default:
                if((*target != TPM_RH_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_ENDORSEMENT Type" (Part 2: Structures)
TPM_RC
TPMI_RH_ENDORSEMENT_Unmarshal(
    TPMI_RH_ENDORSEMENT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_ENDORSEMENT:
                break;
            default:
                if((*target != TPM_RH_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_PROVISION Type" (Part 2: Structures)
TPM_RC
TPMI_RH_PROVISION_Unmarshal(TPMI_RH_PROVISION* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_PLATFORM:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_CLEAR Type" (Part 2: Structures)
TPM_RC
TPMI_RH_CLEAR_Unmarshal(TPMI_RH_CLEAR* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_PLATFORM:
            case TPM_RH_LOCKOUT:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_NV_AUTH Type" (Part 2: Structures)
TPM_RC
TPMI_RH_NV_AUTH_Unmarshal(TPMI_RH_NV_AUTH* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_OWNER:
            case TPM_RH_PLATFORM:
                break;
            default:
                if((*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST))
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_LOCKOUT Type" (Part 2: Structures)
TPM_RC
TPMI_RH_LOCKOUT_Unmarshal(TPMI_RH_LOCKOUT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_RH_LOCKOUT:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}

// Table "Definition of TPMI_RH_NV_INDEX Type" (Part 2: Structures)
TPM_RC
TPMI_RH_NV_INDEX_Unmarshal(TPMI_RH_NV_INDEX* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST))
       && ((*target < EXTERNAL_NV_FIRST) || (*target > EXTERNAL_NV_LAST))
       && ((*target < PERMANENT_NV_FIRST) || (*target > PERMANENT_NV_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_RH_NV_DEFINED_INDEX Type" (Part 2: Structures)
TPM_RC
TPMI_RH_NV_DEFINED_INDEX_Unmarshal(
    TPMI_RH_NV_DEFINED_INDEX* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST))
       && ((*target < EXTERNAL_NV_FIRST) || (*target > EXTERNAL_NV_LAST)))
        result = TPM_RC_VALUE;
    return result;
}

// Table "Definition of TPMI_RH_NV_LEGACY_INDEX Type" (Part 2: Structures)
TPM_RC
TPMI_RH_NV_LEGACY_INDEX_Unmarshal(
    TPMI_RH_NV_LEGACY_INDEX* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_RH_NV_EXP_INDEX Type" (Part 2: Structures)
TPM_RC
TPMI_RH_NV_EXP_INDEX_Unmarshal(
    TPMI_RH_NV_EXP_INDEX* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < EXTERNAL_NV_FIRST) || (*target > EXTERNAL_NV_LAST)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_RH_AC Type" (Part 2: Structures)
TPM_RC
TPMI_RH_AC_Unmarshal(TPMI_RH_AC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS) && ((*target < AC_FIRST) || (*target > AC_LAST)))
        result = TPM_RC_VALUE;
    return result;
}

// Table "Definition of TPMI_RH_ACT Type" (Part 2: Structures)
TPM_RC
TPMI_RH_ACT_Unmarshal(TPMI_RH_ACT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HANDLE_Unmarshal((TPM_HANDLE*)target, buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F)))
        result = TPM_RC_VALUE;
    return result;
}
// Table "Definition of TPMI_ALG_HASH Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_HASH_Unmarshal(TPMI_ALG_HASH* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_SHA1
            case TPM_ALG_SHA1:
#  endif  // ALG_SHA1
#  if ALG_SHA256
            case TPM_ALG_SHA256:
#  endif  // ALG_SHA256
#  if ALG_SHA384
            case TPM_ALG_SHA384:
#  endif  // ALG_SHA384
#  if ALG_SHA512
            case TPM_ALG_SHA512:
#  endif  // ALG_SHA512
#  if ALG_SHA256_192
            case TPM_ALG_SHA256_192:
#  endif  // ALG_SHA256_192
#  if ALG_SM3_256
            case TPM_ALG_SM3_256:
#  endif  // ALG_SM3_256
#  if ALG_SHA3_256
            case TPM_ALG_SHA3_256:
#  endif  // ALG_SHA3_256
#  if ALG_SHA3_384
            case TPM_ALG_SHA3_384:
#  endif  // ALG_SHA3_384
#  if ALG_SHA3_512
            case TPM_ALG_SHA3_512:
#  endif  // ALG_SHA3_512
#  if ALG_SHAKE256_192
            case TPM_ALG_SHAKE256_192:
#  endif  // ALG_SHAKE256_192
#  if ALG_SHAKE256_256
            case TPM_ALG_SHAKE256_256:
#  endif  // ALG_SHAKE256_256
#  if ALG_SHAKE256_512
            case TPM_ALG_SHAKE256_512:
#  endif  // ALG_SHAKE256_512
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_HASH;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_ASYM Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_ASYM_Unmarshal(TPMI_ALG_ASYM* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_RSA
            case TPM_ALG_RSA:
#  endif  // ALG_RSA
#  if ALG_ECC
            case TPM_ALG_ECC:
#  endif  // ALG_ECC
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_ASYMMETRIC;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_SYM Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_SYM_Unmarshal(TPMI_ALG_SYM* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_AES
            case TPM_ALG_AES:
#  endif  // ALG_AES
#  if ALG_XOR
            case TPM_ALG_XOR:
#  endif  // ALG_XOR
#  if ALG_SM4
            case TPM_ALG_SM4:
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
            case TPM_ALG_CAMELLIA:
#  endif  // ALG_CAMELLIA
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SYMMETRIC;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_SYM_OBJECT Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_SYM_OBJECT_Unmarshal(
    TPMI_ALG_SYM_OBJECT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_AES
            case TPM_ALG_AES:
#  endif  // ALG_AES
#  if ALG_SM4
            case TPM_ALG_SM4:
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
            case TPM_ALG_CAMELLIA:
#  endif  // ALG_CAMELLIA
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SYMMETRIC;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_SYM_MODE Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_SYM_MODE_Unmarshal(
    TPMI_ALG_SYM_MODE* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_CMAC
            case TPM_ALG_CMAC:
#  endif  // ALG_CMAC
#  if ALG_CTR
            case TPM_ALG_CTR:
#  endif  // ALG_CTR
#  if ALG_OFB
            case TPM_ALG_OFB:
#  endif  // ALG_OFB
#  if ALG_CBC
            case TPM_ALG_CBC:
#  endif  // ALG_CBC
#  if ALG_CFB
            case TPM_ALG_CFB:
#  endif  // ALG_CFB
#  if ALG_ECB
            case TPM_ALG_ECB:
#  endif  // ALG_ECB
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_MODE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_KDF Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_KDF_Unmarshal(TPMI_ALG_KDF* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_MGF1
            case TPM_ALG_MGF1:
#  endif  // ALG_MGF1
#  if ALG_KDF1_SP800_56A
            case TPM_ALG_KDF1_SP800_56A:
#  endif  // ALG_KDF1_SP800_56A
#  if ALG_KDF2
            case TPM_ALG_KDF2:
#  endif  // ALG_KDF2
#  if ALG_KDF1_SP800_108
            case TPM_ALG_KDF1_SP800_108:
#  endif  // ALG_KDF1_SP800_108
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_KDF;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_SIG_SCHEME Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_SIG_SCHEME_Unmarshal(
    TPMI_ALG_SIG_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_HMAC
            case TPM_ALG_HMAC:
#  endif  // ALG_HMAC
#  if ALG_RSASSA
            case TPM_ALG_RSASSA:
#  endif  // ALG_RSASSA
#  if ALG_RSAPSS
            case TPM_ALG_RSAPSS:
#  endif  // ALG_RSAPSS
#  if ALG_ECDSA
            case TPM_ALG_ECDSA:
#  endif  // ALG_ECDSA
#  if ALG_ECDAA
            case TPM_ALG_ECDAA:
#  endif  // ALG_ECDAA
#  if ALG_SM2
            case TPM_ALG_SM2:
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
            case TPM_ALG_ECSCHNORR:
#  endif  // ALG_ECSCHNORR
#  if ALG_EDDSA
            case TPM_ALG_EDDSA:
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
            case TPM_ALG_EDDSA_PH:
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
            case TPM_ALG_LMS:
#  endif  // ALG_LMS
#  if ALG_XMSS
            case TPM_ALG_XMSS:
#  endif  // ALG_XMSS
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SCHEME;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ECC_KEY_EXCHANGE Type" (Part 2: Structures)

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
#  if ALG_ECC
TPM_RC
TPMI_ECC_KEY_EXCHANGE_Unmarshal(
    TPMI_ECC_KEY_EXCHANGE* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ALG_ECDH
            case TPM_ALG_ECDH:
#    endif  // ALG_ECDH
#    if ALG_SM2
            case TPM_ALG_SM2:
#    endif  // ALG_SM2
#    if ALG_ECMQV
            case TPM_ALG_ECMQV:
#    endif  // ALG_ECMQV
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SCHEME;
                break;
        }
    }
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPMI_ST_COMMAND_TAG Type" (Part 2: Structures)
TPM_RC
TPMI_ST_COMMAND_TAG_Unmarshal(TPMI_ST_COMMAND_TAG* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ST_Unmarshal((TPM_ST*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_ST_NO_SESSIONS:
            case TPM_ST_SESSIONS:
                break;
            default:
                result = TPM_RC_BAD_TAG;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_MAC_SCHEME Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_MAC_SCHEME_Unmarshal(
    TPMI_ALG_MAC_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_SHA1
            case TPM_ALG_SHA1:
#  endif  // ALG_SHA1
#  if ALG_SHA256
            case TPM_ALG_SHA256:
#  endif  // ALG_SHA256
#  if ALG_SHA384
            case TPM_ALG_SHA384:
#  endif  // ALG_SHA384
#  if ALG_SHA512
            case TPM_ALG_SHA512:
#  endif  // ALG_SHA512
#  if ALG_SHA256_192
            case TPM_ALG_SHA256_192:
#  endif  // ALG_SHA256_192
#  if ALG_SM3_256
            case TPM_ALG_SM3_256:
#  endif  // ALG_SM3_256
#  if ALG_SHA3_256
            case TPM_ALG_SHA3_256:
#  endif  // ALG_SHA3_256
#  if ALG_SHA3_384
            case TPM_ALG_SHA3_384:
#  endif  // ALG_SHA3_384
#  if ALG_SHA3_512
            case TPM_ALG_SHA3_512:
#  endif  // ALG_SHA3_512
#  if ALG_SHAKE256_192
            case TPM_ALG_SHAKE256_192:
#  endif  // ALG_SHAKE256_192
#  if ALG_SHAKE256_256
            case TPM_ALG_SHAKE256_256:
#  endif  // ALG_SHAKE256_256
#  if ALG_SHAKE256_512
            case TPM_ALG_SHAKE256_512:
#  endif  // ALG_SHAKE256_512
#  if ALG_CMAC
            case TPM_ALG_CMAC:
#  endif  // ALG_CMAC
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SYMMETRIC;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ALG_CIPHER_MODE Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_CIPHER_MODE_Unmarshal(
    TPMI_ALG_CIPHER_MODE* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_CTR
            case TPM_ALG_CTR:
#  endif  // ALG_CTR
#  if ALG_OFB
            case TPM_ALG_OFB:
#  endif  // ALG_OFB
#  if ALG_CBC
            case TPM_ALG_CBC:
#  endif  // ALG_CBC
#  if ALG_CFB
            case TPM_ALG_CFB:
#  endif  // ALG_CFB
#  if ALG_ECB
            case TPM_ALG_ECB:
#  endif  // ALG_ECB
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_MODE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMS_EMPTY Structure" (Part 2: Structures)
TPM_RC
TPMS_EMPTY_Unmarshal(TPMS_EMPTY* target, BYTE** buffer, INT32* size)
{
    // to prevent the compiler from complaining
    NOT_REFERENCED(target);
    NOT_REFERENCED(buffer);
    NOT_REFERENCED(size);
    return TPM_RC_SUCCESS;
}
UINT16
TPMS_EMPTY_Marshal(TPMS_EMPTY* source, BYTE** buffer, INT32* size)
{
    // to prevent the compiler from complaining
    NOT_REFERENCED(source);
    NOT_REFERENCED(buffer);
    NOT_REFERENCED(size);
    return 0;
}

// Table "Definition of TPMS_ALGORITHM_DESCRIPTION Structure" (Part 2: Structures)
UINT16
TPMS_ALGORITHM_DESCRIPTION_Marshal(
    TPMS_ALGORITHM_DESCRIPTION* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_ALG_ID_Marshal((TPM_ALG_ID*)&(source->alg), buffer, size));
    result = (UINT16)(result
                      + TPMA_ALGORITHM_Marshal(
                          (TPMA_ALGORITHM*)&(source->attributes), buffer, size));
    return result;
}

// Table "Definition of TPMU_HA Union" (Part 2: Structures)
TPM_RC
TPMU_HA_Unmarshal(TPMU_HA* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
#  if ALG_SHA1
        case TPM_ALG_SHA1:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->sha1), buffer, size, (INT32)SHA1_DIGEST_SIZE);
#  endif  // ALG_SHA1
#  if ALG_SHA256
        case TPM_ALG_SHA256:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->sha256), buffer, size, (INT32)SHA256_DIGEST_SIZE);
#  endif  // ALG_SHA256
#  if ALG_SHA256_192
        case TPM_ALG_SHA256_192:
            return BYTE_Array_Unmarshal((BYTE*)&(target->sha256_192),
                                        buffer,
                                        size,
                                        (INT32)SHA256_192_DIGEST_SIZE);
#  endif  // ALG_SHA256_192
#  if ALG_SHA3_256
        case TPM_ALG_SHA3_256:
            return BYTE_Array_Unmarshal((BYTE*)&(target->sha3_256),
                                        buffer,
                                        size,
                                        (INT32)SHA3_256_DIGEST_SIZE);
#  endif  // ALG_SHA3_256
#  if ALG_SHA3_384
        case TPM_ALG_SHA3_384:
            return BYTE_Array_Unmarshal((BYTE*)&(target->sha3_384),
                                        buffer,
                                        size,
                                        (INT32)SHA3_384_DIGEST_SIZE);
#  endif  // ALG_SHA3_384
#  if ALG_SHA3_512
        case TPM_ALG_SHA3_512:
            return BYTE_Array_Unmarshal((BYTE*)&(target->sha3_512),
                                        buffer,
                                        size,
                                        (INT32)SHA3_512_DIGEST_SIZE);
#  endif  // ALG_SHA3_512
#  if ALG_SHA384
        case TPM_ALG_SHA384:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->sha384), buffer, size, (INT32)SHA384_DIGEST_SIZE);
#  endif  // ALG_SHA384
#  if ALG_SHA512
        case TPM_ALG_SHA512:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->sha512), buffer, size, (INT32)SHA512_DIGEST_SIZE);
#  endif  // ALG_SHA512
#  if ALG_SHAKE256_192
        case TPM_ALG_SHAKE256_192:
            return BYTE_Array_Unmarshal((BYTE*)&(target->shake256_192),
                                        buffer,
                                        size,
                                        (INT32)SHAKE256_192_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_192
#  if ALG_SHAKE256_256
        case TPM_ALG_SHAKE256_256:
            return BYTE_Array_Unmarshal((BYTE*)&(target->shake256_256),
                                        buffer,
                                        size,
                                        (INT32)SHAKE256_256_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_256
#  if ALG_SHAKE256_512
        case TPM_ALG_SHAKE256_512:
            return BYTE_Array_Unmarshal((BYTE*)&(target->shake256_512),
                                        buffer,
                                        size,
                                        (INT32)SHAKE256_512_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_512
#  if ALG_SM3_256
        case TPM_ALG_SM3_256:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->sm3_256), buffer, size, (INT32)SM3_256_DIGEST_SIZE);
#  endif  // ALG_SM3_256
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_HA_Marshal(TPMU_HA* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_SHA1
        case TPM_ALG_SHA1:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->sha1), buffer, size, (INT32)SHA1_DIGEST_SIZE);
#  endif  // ALG_SHA1
#  if ALG_SHA256
        case TPM_ALG_SHA256:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->sha256), buffer, size, (INT32)SHA256_DIGEST_SIZE);
#  endif  // ALG_SHA256
#  if ALG_SHA256_192
        case TPM_ALG_SHA256_192:
            return BYTE_Array_Marshal((BYTE*)&(source->sha256_192),
                                      buffer,
                                      size,
                                      (INT32)SHA256_192_DIGEST_SIZE);
#  endif  // ALG_SHA256_192
#  if ALG_SHA3_256
        case TPM_ALG_SHA3_256:
            return BYTE_Array_Marshal((BYTE*)&(source->sha3_256),
                                      buffer,
                                      size,
                                      (INT32)SHA3_256_DIGEST_SIZE);
#  endif  // ALG_SHA3_256
#  if ALG_SHA3_384
        case TPM_ALG_SHA3_384:
            return BYTE_Array_Marshal((BYTE*)&(source->sha3_384),
                                      buffer,
                                      size,
                                      (INT32)SHA3_384_DIGEST_SIZE);
#  endif  // ALG_SHA3_384
#  if ALG_SHA3_512
        case TPM_ALG_SHA3_512:
            return BYTE_Array_Marshal((BYTE*)&(source->sha3_512),
                                      buffer,
                                      size,
                                      (INT32)SHA3_512_DIGEST_SIZE);
#  endif  // ALG_SHA3_512
#  if ALG_SHA384
        case TPM_ALG_SHA384:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->sha384), buffer, size, (INT32)SHA384_DIGEST_SIZE);
#  endif  // ALG_SHA384
#  if ALG_SHA512
        case TPM_ALG_SHA512:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->sha512), buffer, size, (INT32)SHA512_DIGEST_SIZE);
#  endif  // ALG_SHA512
#  if ALG_SHAKE256_192
        case TPM_ALG_SHAKE256_192:
            return BYTE_Array_Marshal((BYTE*)&(source->shake256_192),
                                      buffer,
                                      size,
                                      (INT32)SHAKE256_192_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_192
#  if ALG_SHAKE256_256
        case TPM_ALG_SHAKE256_256:
            return BYTE_Array_Marshal((BYTE*)&(source->shake256_256),
                                      buffer,
                                      size,
                                      (INT32)SHAKE256_256_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_256
#  if ALG_SHAKE256_512
        case TPM_ALG_SHAKE256_512:
            return BYTE_Array_Marshal((BYTE*)&(source->shake256_512),
                                      buffer,
                                      size,
                                      (INT32)SHAKE256_512_DIGEST_SIZE);
#  endif  // ALG_SHAKE256_512
#  if ALG_SM3_256
        case TPM_ALG_SM3_256:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->sm3_256), buffer, size, (INT32)SM3_256_DIGEST_SIZE);
#  endif  // ALG_SM3_256
    }
    return 0;
}

// Table "Definition of TPMT_HA Structure" (Part 2: Structures)
TPM_RC
TPMT_HA_Unmarshal(TPMT_HA* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_HASH_Unmarshal(
        (TPMI_ALG_HASH*)&(target->hashAlg), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_HA_Unmarshal(
            (TPMU_HA*)&(target->digest), buffer, size, (UINT32)target->hashAlg);
    return result;
}
UINT16
TPMT_HA_Marshal(TPMT_HA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hashAlg), buffer, size));
    result        = (UINT16)(result
                      + TPMU_HA_Marshal((TPMU_HA*)&(source->digest),
                                        buffer,
                                        size,
                                        (UINT32)source->hashAlg));
    return result;
}

// Table "Definition of TPM2B_DIGEST Structure" (Part 2: Structures)
TPM_RC
TPM2B_DIGEST_Unmarshal(TPM2B_DIGEST* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMU_HA)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_DIGEST_Marshal(TPM2B_DIGEST* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_DATA Structure" (Part 2: Structures)
TPM_RC
TPM2B_DATA_Unmarshal(TPM2B_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMT_HA)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_DATA_Marshal(TPM2B_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_EVENT Structure" (Part 2: Structures)
TPM_RC
TPM2B_EVENT_Unmarshal(TPM2B_EVENT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > 1024))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_EVENT_Marshal(TPM2B_EVENT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_MAX_BUFFER Structure" (Part 2: Structures)
TPM_RC
TPM2B_MAX_BUFFER_Unmarshal(TPM2B_MAX_BUFFER* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_DIGEST_BUFFER))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_MAX_NV_BUFFER Structure" (Part 2: Structures)
TPM_RC
TPM2B_MAX_NV_BUFFER_Unmarshal(TPM2B_MAX_NV_BUFFER* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_NV_BUFFER_SIZE))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_MAX_NV_BUFFER_Marshal(TPM2B_MAX_NV_BUFFER* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_TIMEOUT Structure" (Part 2: Structures)
TPM_RC
TPM2B_TIMEOUT_Unmarshal(TPM2B_TIMEOUT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(UINT64)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_TIMEOUT_Marshal(TPM2B_TIMEOUT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_IV Structure" (Part 2: Structures)
TPM_RC
TPM2B_IV_Unmarshal(TPM2B_IV* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_SYM_BLOCK_SIZE))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_IV_Marshal(TPM2B_IV* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_VENDOR_PROPERTY Structure" (Part 2: Structures)
TPM_RC
TPM2B_VENDOR_PROPERTY_Unmarshal(
    TPM2B_VENDOR_PROPERTY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > 512))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_VENDOR_PROPERTY_Marshal(
    TPM2B_VENDOR_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_NAME Structure" (Part 2: Structures)
TPM_RC
TPM2B_NAME_Unmarshal(TPM2B_NAME* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMU_NAME)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.name), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_NAME_Marshal(TPM2B_NAME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result =
        (UINT16)(result
                 + BYTE_Array_Marshal(
                     (BYTE*)&(source->t.name), buffer, size, (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_PCR_SELECT Structure" (Part 2: Structures)
TPM_RC
TPMS_PCR_SELECT_Unmarshal(TPMS_PCR_SELECT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT8_Unmarshal((UINT8*)&(target->sizeofSelect), buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((target->sizeofSelect < PCR_SELECT_MIN)
           || (target->sizeofSelect > PCR_SELECT_MAX)))
        result = TPM_RC_VALUE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->pcrSelect), buffer, size, (INT32)target->sizeofSelect);
    return result;
}
UINT16
TPMS_PCR_SELECT_Marshal(TPMS_PCR_SELECT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + UINT8_Marshal((UINT8*)&(source->sizeofSelect), buffer, size));
    result        = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->pcrSelect),
                                           buffer,
                                           size,
                                           (INT32)source->sizeofSelect));
    return result;
}

// Table "Definition of TPMS_PCR_SELECTION Structure" (Part 2: Structures)
TPM_RC
TPMS_PCR_SELECTION_Unmarshal(TPMS_PCR_SELECTION* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hash), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = UINT8_Unmarshal((UINT8*)&(target->sizeofSelect), buffer, size);
    if((result == TPM_RC_SUCCESS)
       && ((target->sizeofSelect < PCR_SELECT_MIN)
           || (target->sizeofSelect > PCR_SELECT_MAX)))
        result = TPM_RC_VALUE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->pcrSelect), buffer, size, (INT32)target->sizeofSelect);
    return result;
}
UINT16
TPMS_PCR_SELECTION_Marshal(TPMS_PCR_SELECTION* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hash), buffer, size));
    result        = (UINT16)(result
                      + UINT8_Marshal((UINT8*)&(source->sizeofSelect), buffer, size));
    result        = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->pcrSelect),
                                           buffer,
                                           size,
                                           (INT32)source->sizeofSelect));
    return result;
}

// Table "Definition of TPMT_TK_CREATION Structure" (Part 2: Structures)
TPM_RC
TPMT_TK_CREATION_Unmarshal(TPMT_TK_CREATION* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ST_Unmarshal((TPM_ST*)&(target->tag), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->tag != TPM_ST_CREATION))
        result = TPM_RC_TAG;
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RH_HIERARCHY_Unmarshal(
            (TPMI_RH_HIERARCHY*)&(target->hierarchy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->digest), buffer, size);
    return result;
}
UINT16
TPMT_TK_CREATION_Marshal(TPMT_TK_CREATION* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result = (UINT16)(result + TPM_ST_Marshal((TPM_ST*)&(source->tag), buffer, size));
    result = (UINT16)(result
                      + TPMI_RH_HIERARCHY_Marshal(
                          (TPMI_RH_HIERARCHY*)&(source->hierarchy), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->digest), buffer, size));
    return result;
}

// Table "Definition of TPMT_TK_VERIFIED Structure" (Part 2: Structures)
TPM_RC
TPMT_TK_VERIFIED_Unmarshal(TPMT_TK_VERIFIED* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ST_Unmarshal((TPM_ST*)&(target->tag), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->tag != TPM_ST_VERIFIED))
        result = TPM_RC_TAG;
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RH_HIERARCHY_Unmarshal(
            (TPMI_RH_HIERARCHY*)&(target->hierarchy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->digest), buffer, size);
    return result;
}
UINT16
TPMT_TK_VERIFIED_Marshal(TPMT_TK_VERIFIED* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result = (UINT16)(result + TPM_ST_Marshal((TPM_ST*)&(source->tag), buffer, size));
    result = (UINT16)(result
                      + TPMI_RH_HIERARCHY_Marshal(
                          (TPMI_RH_HIERARCHY*)&(source->hierarchy), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->digest), buffer, size));
    return result;
}

// Table "Definition of TPMT_TK_AUTH Structure" (Part 2: Structures)
TPM_RC
TPMT_TK_AUTH_Unmarshal(TPMT_TK_AUTH* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ST_Unmarshal((TPM_ST*)&(target->tag), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->tag != TPM_ST_AUTH_SIGNED)
       && (target->tag != TPM_ST_AUTH_SECRET))
        result = TPM_RC_TAG;
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RH_HIERARCHY_Unmarshal(
            (TPMI_RH_HIERARCHY*)&(target->hierarchy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->digest), buffer, size);
    return result;
}
UINT16
TPMT_TK_AUTH_Marshal(TPMT_TK_AUTH* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result = (UINT16)(result + TPM_ST_Marshal((TPM_ST*)&(source->tag), buffer, size));
    result = (UINT16)(result
                      + TPMI_RH_HIERARCHY_Marshal(
                          (TPMI_RH_HIERARCHY*)&(source->hierarchy), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->digest), buffer, size));
    return result;
}

// Table "Definition of TPMT_TK_HASHCHECK Structure" (Part 2: Structures)
TPM_RC
TPMT_TK_HASHCHECK_Unmarshal(TPMT_TK_HASHCHECK* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ST_Unmarshal((TPM_ST*)&(target->tag), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->tag != TPM_ST_HASHCHECK))
        result = TPM_RC_TAG;
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RH_HIERARCHY_Unmarshal(
            (TPMI_RH_HIERARCHY*)&(target->hierarchy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->digest), buffer, size);
    return result;
}
UINT16
TPMT_TK_HASHCHECK_Marshal(TPMT_TK_HASHCHECK* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result = (UINT16)(result + TPM_ST_Marshal((TPM_ST*)&(source->tag), buffer, size));
    result = (UINT16)(result
                      + TPMI_RH_HIERARCHY_Marshal(
                          (TPMI_RH_HIERARCHY*)&(source->hierarchy), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->digest), buffer, size));
    return result;
}

// Table "Definition of TPMS_ALG_PROPERTY Structure" (Part 2: Structures)
UINT16
TPMS_ALG_PROPERTY_Marshal(TPMS_ALG_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_ALG_ID_Marshal((TPM_ALG_ID*)&(source->alg), buffer, size));
    result = (UINT16)(result
                      + TPMA_ALGORITHM_Marshal(
                          (TPMA_ALGORITHM*)&(source->algProperties), buffer, size));
    return result;
}

// Table "Definition of TPMS_TAGGED_PROPERTY Structure" (Part 2: Structures)
UINT16
TPMS_TAGGED_PROPERTY_Marshal(TPMS_TAGGED_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + TPM_PT_Marshal((TPM_PT*)&(source->property), buffer, size));
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->value), buffer, size));
    return result;
}

// Table "Definition of TPMS_TAGGED_PCR_SELECT Structure" (Part 2: Structures)
UINT16
TPMS_TAGGED_PCR_SELECT_Marshal(
    TPMS_TAGGED_PCR_SELECT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_PT_PCR_Marshal((TPM_PT_PCR*)&(source->tag), buffer, size));
    result = (UINT16)(result
                      + UINT8_Marshal((UINT8*)&(source->sizeofSelect), buffer, size));
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->pcrSelect),
                                           buffer,
                                           size,
                                           (INT32)source->sizeofSelect));
    return result;
}

// Table "Definition of TPMS_TAGGED_POLICY Structure" (Part 2: Structures)
UINT16
TPMS_TAGGED_POLICY_Marshal(TPMS_TAGGED_POLICY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_HANDLE_Marshal((TPM_HANDLE*)&(source->handle), buffer, size));
    result =
        (UINT16)(result
                 + TPMT_HA_Marshal((TPMT_HA*)&(source->policyHash), buffer, size));
    return result;
}

// Table "Definition of TPMS_ACT_DATA Structure" (Part 2: Structures)
UINT16
TPMS_ACT_DATA_Marshal(TPMS_ACT_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_HANDLE_Marshal((TPM_HANDLE*)&(source->handle), buffer, size));
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->timeout), buffer, size));
    result =
        (UINT16)(result
                 + TPMA_ACT_Marshal((TPMA_ACT*)&(source->attributes), buffer, size));
    return result;
}

#  if SEC_CHANNEL_SUPPORT
// Table "Definition of TPMS_SPDM_SESSION_INFO Structure" (Part 2: Structures)
UINT16
TPMS_SPDM_SESSION_INFO_Marshal(
    TPMS_SPDM_SESSION_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->reqKeyName), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->tpmKeyName), buffer, size));
    return result;
}
#  endif  // SEC_CHANNEL_SUPPORT

// Table "Definition of TPML_CC Structure" (Part 2: Structures)
TPM_RC
TPML_CC_Unmarshal(TPML_CC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->count > MAX_CAP_CC))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = TPM_CC_Array_Unmarshal(
            (TPM_CC*)&(target->commandCodes), buffer, size, (INT32)target->count);
    return result;
}
UINT16
TPML_CC_Marshal(TPML_CC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM_CC_Array_Marshal((TPM_CC*)&(source->commandCodes),
                                             buffer,
                                             size,
                                             (INT32)source->count));
    return result;
}

// Table "Definition of TPML_CCA Structure" (Part 2: Structures)
UINT16
TPML_CCA_Marshal(TPML_CCA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMA_CC_Array_Marshal((TPMA_CC*)&(source->commandAttributes),
                                              buffer,
                                              size,
                                              (INT32)source->count));
    return result;
}

// Table "Definition of TPML_ALG Structure" (Part 2: Structures)
TPM_RC
TPML_ALG_Unmarshal(TPML_ALG* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->count > MAX_ALG_LIST_SIZE))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = TPM_ALG_ID_Array_Unmarshal(
            (TPM_ALG_ID*)&(target->algorithms), buffer, size, (INT32)target->count);
    return result;
}
UINT16
TPML_ALG_Marshal(TPML_ALG* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM_ALG_ID_Array_Marshal((TPM_ALG_ID*)&(source->algorithms),
                                                 buffer,
                                                 size,
                                                 (INT32)source->count));
    return result;
}

// Table "Definition of TPML_HANDLE Structure" (Part 2: Structures)
UINT16
TPML_HANDLE_Marshal(TPML_HANDLE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM_HANDLE_Array_Marshal((TPM_HANDLE*)&(source->handle),
                                                 buffer,
                                                 size,
                                                 (INT32)source->count));
    return result;
}

// Table "Definition of TPML_DIGEST Structure" (Part 2: Structures)
TPM_RC
TPML_DIGEST_Unmarshal(TPML_DIGEST* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && ((target->count < 2) || (target->count > 8)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_DIGEST_Array_Unmarshal(
            (TPM2B_DIGEST*)&(target->digests), buffer, size, (INT32)target->count);
    return result;
}
UINT16
TPML_DIGEST_Marshal(TPML_DIGEST* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Array_Marshal((TPM2B_DIGEST*)&(source->digests),
                                                   buffer,
                                                   size,
                                                   (INT32)source->count));
    return result;
}

// Table "Definition of TPML_DIGEST_VALUES Structure" (Part 2: Structures)
TPM_RC
TPML_DIGEST_VALUES_Unmarshal(TPML_DIGEST_VALUES* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->count > HASH_COUNT))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = TPMT_HA_Array_Unmarshal(
            (TPMT_HA*)&(target->digests), buffer, size, 0, (INT32)target->count);
    return result;
}
UINT16
TPML_DIGEST_VALUES_Marshal(TPML_DIGEST_VALUES* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMT_HA_Array_Marshal((TPMT_HA*)&(source->digests),
                                              buffer,
                                              size,
                                              (INT32)source->count));
    return result;
}

// Table "Definition of TPML_PCR_SELECTION Structure" (Part 2: Structures)
TPM_RC
TPML_PCR_SELECTION_Unmarshal(TPML_PCR_SELECTION* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->count > HASH_COUNT))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = TPMS_PCR_SELECTION_Array_Unmarshal(
            (TPMS_PCR_SELECTION*)&(target->pcrSelections),
            buffer,
            size,
            (INT32)target->count);
    return result;
}
UINT16
TPML_PCR_SELECTION_Marshal(TPML_PCR_SELECTION* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_PCR_SELECTION_Array_Marshal(
                          (TPMS_PCR_SELECTION*)&(source->pcrSelections),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// Table "Definition of TPML_ALG_PROPERTY Structure" (Part 2: Structures)
UINT16
TPML_ALG_PROPERTY_Marshal(TPML_ALG_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_ALG_PROPERTY_Array_Marshal(
                          (TPMS_ALG_PROPERTY*)&(source->algProperties),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// Table "Definition of TPML_TAGGED_TPM_PROPERTY Structure" (Part 2: Structures)
UINT16
TPML_TAGGED_TPM_PROPERTY_Marshal(
    TPML_TAGGED_TPM_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_TAGGED_PROPERTY_Array_Marshal(
                          (TPMS_TAGGED_PROPERTY*)&(source->tpmProperty),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// Table "Definition of TPML_TAGGED_PCR_PROPERTY Structure" (Part 2: Structures)
UINT16
TPML_TAGGED_PCR_PROPERTY_Marshal(
    TPML_TAGGED_PCR_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_TAGGED_PCR_SELECT_Array_Marshal(
                          (TPMS_TAGGED_PCR_SELECT*)&(source->pcrProperty),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPML_ECC_CURVE Structure" (Part 2: Structures)
#  if ALG_ECC
UINT16
TPML_ECC_CURVE_Marshal(TPML_ECC_CURVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result =
        (UINT16)(result
                 + TPM_ECC_CURVE_Array_Marshal((TPM_ECC_CURVE*)&(source->eccCurves),
                                               buffer,
                                               size,
                                               (INT32)source->count));
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPML_TAGGED_POLICY Structure" (Part 2: Structures)
UINT16
TPML_TAGGED_POLICY_Marshal(TPML_TAGGED_POLICY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_TAGGED_POLICY_Array_Marshal(
                          (TPMS_TAGGED_POLICY*)&(source->policies),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// Table "Definition of TPML_ACT_DATA Structure" (Part 2: Structures)
UINT16
TPML_ACT_DATA_Marshal(TPML_ACT_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result =
        (UINT16)(result
                 + TPMS_ACT_DATA_Array_Marshal((TPMS_ACT_DATA*)&(source->actData),
                                               buffer,
                                               size,
                                               (INT32)source->count));
    return result;
}

#  if SEC_CHANNEL_SUPPORT
// Table "Definition of TPML_PUB_KEY Structure" (Part 2: Structures)
UINT16
TPML_PUB_KEY_Marshal(TPML_PUB_KEY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM2B_PUBLIC_Array_Marshal((TPM2B_PUBLIC*)&(source->pubKeys),
                                                   buffer,
                                                   size,
                                                   (INT32)source->count));
    return result;
}

// Table "Definition of TPML_SPDM_SESSION_INFO Structure" (Part 2: Structures)
UINT16
TPML_SPDM_SESSION_INFO_Marshal(
    TPML_SPDM_SESSION_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_SPDM_SESSION_INFO_Array_Marshal(
                          (TPMS_SPDM_SESSION_INFO*)&(source->spdmSessionInfo),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}
#  endif  // SEC_CHANNEL_SUPPORT

// Table "Definition of TPML_VENDOR_PROPERTY Structure" (Part 2: Structures)
TPM_RC
TPML_VENDOR_PROPERTY_Unmarshal(
    TPML_VENDOR_PROPERTY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->count), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->count > MAX_VENDOR_PROPERTY))
        result = TPM_RC_VALUE;
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_VENDOR_PROPERTY_Array_Unmarshal(
            (TPM2B_VENDOR_PROPERTY*)&(target->vendorData),
            buffer,
            size,
            (INT32)target->count);
    return result;
}
UINT16
TPML_VENDOR_PROPERTY_Marshal(TPML_VENDOR_PROPERTY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPM2B_VENDOR_PROPERTY_Array_Marshal(
                          (TPM2B_VENDOR_PROPERTY*)&(source->vendorData),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// Table "Definition of TPMU_CAPABILITIES Union" (Part 2: Structures)
UINT16
TPMU_CAPABILITIES_Marshal(
    TPMU_CAPABILITIES* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
        case TPM_CAP_ALGS:
            return TPML_ALG_PROPERTY_Marshal(
                (TPML_ALG_PROPERTY*)&(source->algorithms), buffer, size);
        case TPM_CAP_HANDLES:
            return TPML_HANDLE_Marshal(
                (TPML_HANDLE*)&(source->handles), buffer, size);
        case TPM_CAP_COMMANDS:
            return TPML_CCA_Marshal((TPML_CCA*)&(source->command), buffer, size);
        case TPM_CAP_PP_COMMANDS:
            return TPML_CC_Marshal((TPML_CC*)&(source->ppCommands), buffer, size);
        case TPM_CAP_AUDIT_COMMANDS:
            return TPML_CC_Marshal((TPML_CC*)&(source->auditCommands), buffer, size);
        case TPM_CAP_PCRS:
            return TPML_PCR_SELECTION_Marshal(
                (TPML_PCR_SELECTION*)&(source->assignedPCR), buffer, size);
        case TPM_CAP_TPM_PROPERTIES:
            return TPML_TAGGED_TPM_PROPERTY_Marshal(
                (TPML_TAGGED_TPM_PROPERTY*)&(source->tpmProperties), buffer, size);
        case TPM_CAP_PCR_PROPERTIES:
            return TPML_TAGGED_PCR_PROPERTY_Marshal(
                (TPML_TAGGED_PCR_PROPERTY*)&(source->pcrProperties), buffer, size);
#  if ALG_ECC
        case TPM_CAP_ECC_CURVES:
            return TPML_ECC_CURVE_Marshal(
                (TPML_ECC_CURVE*)&(source->eccCurves), buffer, size);
#  endif  // ALG_ECC
        case TPM_CAP_AUTH_POLICIES:
            return TPML_TAGGED_POLICY_Marshal(
                (TPML_TAGGED_POLICY*)&(source->authPolicies), buffer, size);
        case TPM_CAP_ACT:
            return TPML_ACT_DATA_Marshal(
                (TPML_ACT_DATA*)&(source->actData), buffer, size);
#  if SEC_CHANNEL_SUPPORT
        case TPM_CAP_PUB_KEYS:
            return TPML_PUB_KEY_Marshal(
                (TPML_PUB_KEY*)&(source->pubKeys), buffer, size);
        case TPM_CAP_SPDM_SESSION_INFO:
            return TPML_SPDM_SESSION_INFO_Marshal(
                (TPML_SPDM_SESSION_INFO*)&(source->spdmSessionInfo), buffer, size);
#  endif  // SEC_CHANNEL_SUPPORT
    }
    return 0;
}

// Table "Definition of TPMS_CAPABILITY_DATA Structure" (Part 2: Structures)
UINT16
TPMS_CAPABILITY_DATA_Marshal(TPMS_CAPABILITY_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM_CAP_Marshal((TPM_CAP*)&(source->capability), buffer, size));
    result = (UINT16)(result
                      + TPMU_CAPABILITIES_Marshal((TPMU_CAPABILITIES*)&(source->data),
                                                  buffer,
                                                  size,
                                                  (UINT32)source->capability));
    return result;
}

// Defined in an additional Capabilities registry
TPM_RC
TPMU_SET_CAPABILITIES_Unmarshal(
    TPMU_SET_CAPABILITIES* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    // No settable capabilities are currently defined in the reference code.
    NOT_REFERENCED(target);
    NOT_REFERENCED(buffer);
    NOT_REFERENCED(size);
    NOT_REFERENCED(selector);
    return TPM_RC_SELECTOR;
}

// Table "Definition of TPMS_SET_CAPABILITY_DATA Structure" (Part 2: Structures)
TPM_RC
TPMS_SET_CAPABILITY_DATA_Unmarshal(
    TPMS_SET_CAPABILITY_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_CAP_Unmarshal(&target->setCapability, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        result = TPMU_SET_CAPABILITIES_Unmarshal(
            &target->data, buffer, size, (UINT32)target->setCapability);
    }
    return result;
}

// Table "Definition of TPM2B_SET_CAPABILITY_DATA Structure" (Part 2: Structures)
TPM_RC
TPM2B_SET_CAPABILITY_DATA_Unmarshal(
    TPM2B_SET_CAPABILITY_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMS_SET_CAPABILITY_DATA_Unmarshal(
                &target->setCapabilityData, buffer, size);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}

// Table "Definition of TPMS_CLOCK_INFO Structure" (Part 2: Structures)
TPM_RC
TPMS_CLOCK_INFO_Unmarshal(TPMS_CLOCK_INFO* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT64_Unmarshal((UINT64*)&(target->clock), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT32_Unmarshal((UINT32*)&(target->resetCount), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT32_Unmarshal((UINT32*)&(target->restartCount), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_YES_NO_Unmarshal((TPMI_YES_NO*)&(target->safe), buffer, size);
    return result;
}
UINT16
TPMS_CLOCK_INFO_Marshal(TPMS_CLOCK_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT64_Marshal((UINT64*)&(source->clock), buffer, size));
    result = (UINT16)(result
                      + UINT32_Marshal((UINT32*)&(source->resetCount), buffer, size));
    result =
        (UINT16)(result
                 + UINT32_Marshal((UINT32*)&(source->restartCount), buffer, size));
    result =
        (UINT16)(result
                 + TPMI_YES_NO_Marshal((TPMI_YES_NO*)&(source->safe), buffer, size));
    return result;
}

// Table "Definition of TPMS_TIME_INFO Structure" (Part 2: Structures)
TPM_RC
TPMS_TIME_INFO_Unmarshal(TPMS_TIME_INFO* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT64_Unmarshal((UINT64*)&(target->time), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMS_CLOCK_INFO_Unmarshal(
            (TPMS_CLOCK_INFO*)&(target->clockInfo), buffer, size);
    return result;
}
UINT16
TPMS_TIME_INFO_Marshal(TPMS_TIME_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT64_Marshal((UINT64*)&(source->time), buffer, size));
    result = (UINT16)(result
                      + TPMS_CLOCK_INFO_Marshal(
                          (TPMS_CLOCK_INFO*)&(source->clockInfo), buffer, size));
    return result;
}

// Table "Definition of TPMS_TIME_ATTEST_INFO Structure" (Part 2: Structures)
UINT16
TPMS_TIME_ATTEST_INFO_Marshal(
    TPMS_TIME_ATTEST_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMS_TIME_INFO_Marshal(
                          (TPMS_TIME_INFO*)&(source->time), buffer, size));
    result =
        (UINT16)(result
                 + UINT64_Marshal((UINT64*)&(source->firmwareVersion), buffer, size));
    return result;
}

// Table "Definition of TPMS_CERTIFY_INFO Structure" (Part 2: Structures)
UINT16
TPMS_CERTIFY_INFO_Marshal(TPMS_CERTIFY_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM2B_NAME_Marshal((TPM2B_NAME*)&(source->name), buffer, size));
    result = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->qualifiedName), buffer, size));
    return result;
}

// Table "Definition of TPMS_QUOTE_INFO Structure" (Part 2: Structures)
UINT16
TPMS_QUOTE_INFO_Marshal(TPMS_QUOTE_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPML_PCR_SELECTION_Marshal(
                          (TPML_PCR_SELECTION*)&(source->pcrSelect), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->pcrDigest), buffer, size));
    return result;
}

// Table "Definition of TPMS_COMMAND_AUDIT_INFO Structure" (Part 2: Structures)
UINT16
TPMS_COMMAND_AUDIT_INFO_Marshal(
    TPMS_COMMAND_AUDIT_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + UINT64_Marshal((UINT64*)&(source->auditCounter), buffer, size));
    result = (UINT16)(result
                      + TPM_ALG_ID_Marshal(
                          (TPM_ALG_ID*)&(source->digestAlg), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->auditDigest), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->commandDigest), buffer, size));
    return result;
}

// Table "Definition of TPMS_SESSION_AUDIT_INFO Structure" (Part 2: Structures)
UINT16
TPMS_SESSION_AUDIT_INFO_Marshal(
    TPMS_SESSION_AUDIT_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_YES_NO_Marshal(
                          (TPMI_YES_NO*)&(source->exclusiveSession), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->sessionDigest), buffer, size));
    return result;
}

// Table "Definition of TPMS_CREATION_INFO Structure" (Part 2: Structures)
UINT16
TPMS_CREATION_INFO_Marshal(TPMS_CREATION_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->objectName), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->creationHash), buffer, size));
    return result;
}

// Table "Definition of TPMS_NV_CERTIFY_INFO Structure" (Part 2: Structures)
UINT16
TPMS_NV_CERTIFY_INFO_Marshal(TPMS_NV_CERTIFY_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->indexName), buffer, size));
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->offset), buffer, size));
    result = (UINT16)(result
                      + TPM2B_MAX_NV_BUFFER_Marshal(
                          (TPM2B_MAX_NV_BUFFER*)&(source->nvContents), buffer, size));
    return result;
}

// Table "Definition of TPMS_NV_DIGEST_CERTIFY_INFO Structure" (Part 2: Structures)
UINT16
TPMS_NV_DIGEST_CERTIFY_INFO_Marshal(
    TPMS_NV_DIGEST_CERTIFY_INFO* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->indexName), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->nvDigest), buffer, size));
    return result;
}

// Table "Definition of TPMU_ATTEST Union" (Part 2: Structures)
UINT16
TPMU_ATTEST_Marshal(TPMU_ATTEST* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
        case TPM_ST_ATTEST_CERTIFY:
            return TPMS_CERTIFY_INFO_Marshal(
                (TPMS_CERTIFY_INFO*)&(source->certify), buffer, size);
        case TPM_ST_ATTEST_CREATION:
            return TPMS_CREATION_INFO_Marshal(
                (TPMS_CREATION_INFO*)&(source->creation), buffer, size);
        case TPM_ST_ATTEST_QUOTE:
            return TPMS_QUOTE_INFO_Marshal(
                (TPMS_QUOTE_INFO*)&(source->quote), buffer, size);
        case TPM_ST_ATTEST_COMMAND_AUDIT:
            return TPMS_COMMAND_AUDIT_INFO_Marshal(
                (TPMS_COMMAND_AUDIT_INFO*)&(source->commandAudit), buffer, size);
        case TPM_ST_ATTEST_SESSION_AUDIT:
            return TPMS_SESSION_AUDIT_INFO_Marshal(
                (TPMS_SESSION_AUDIT_INFO*)&(source->sessionAudit), buffer, size);
        case TPM_ST_ATTEST_TIME:
            return TPMS_TIME_ATTEST_INFO_Marshal(
                (TPMS_TIME_ATTEST_INFO*)&(source->time), buffer, size);
        case TPM_ST_ATTEST_NV:
            return TPMS_NV_CERTIFY_INFO_Marshal(
                (TPMS_NV_CERTIFY_INFO*)&(source->nv), buffer, size);
        case TPM_ST_ATTEST_NV_DIGEST:
            return TPMS_NV_DIGEST_CERTIFY_INFO_Marshal(
                (TPMS_NV_DIGEST_CERTIFY_INFO*)&(source->nvDigest), buffer, size);
    }
    return 0;
}

// Table "Definition of TPMS_ATTEST Structure" (Part 2: Structures)
UINT16
TPMS_ATTEST_Marshal(TPMS_ATTEST* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM_CONSTANTS32_Marshal(
                          (TPM_CONSTANTS32*)&(source->magic), buffer, size));
    result        = (UINT16)(result
                      + TPMI_ST_ATTEST_Marshal(
                          (TPMI_ST_ATTEST*)&(source->type), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->qualifiedSigner), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DATA_Marshal(
                          (TPM2B_DATA*)&(source->extraData), buffer, size));
    result        = (UINT16)(result
                      + TPMS_CLOCK_INFO_Marshal(
                          (TPMS_CLOCK_INFO*)&(source->clockInfo), buffer, size));
    result =
        (UINT16)(result
                 + UINT64_Marshal((UINT64*)&(source->firmwareVersion), buffer, size));
    result = (UINT16)(result
                      + TPMU_ATTEST_Marshal((TPMU_ATTEST*)&(source->attested),
                                            buffer,
                                            size,
                                            (UINT32)source->type));
    return result;
}

// Table "Definition of TPM2B_ATTEST Structure" (Part 2: Structures)
UINT16
TPM2B_ATTEST_Marshal(TPM2B_ATTEST* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.attestationData),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_AUTH_COMMAND Structure" (Part 2: Structures)
TPM_RC
TPMS_AUTH_COMMAND_Unmarshal(TPMS_AUTH_COMMAND* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMI_SH_AUTH_SESSION_Unmarshal(
        (TPMI_SH_AUTH_SESSION*)&(target->sessionHandle), buffer, size, 1);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_NONCE_Unmarshal((TPM2B_NONCE*)&(target->nonce), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMA_SESSION_Unmarshal(
            (TPMA_SESSION*)&(target->sessionAttributes), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_AUTH_Unmarshal((TPM2B_AUTH*)&(target->hmac), buffer, size);
    return result;
}

// Table "Definition of TPMS_AUTH_RESPONSE Structure" (Part 2: Structures)
UINT16
TPMS_AUTH_RESPONSE_Marshal(TPMS_AUTH_RESPONSE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM2B_NONCE_Marshal((TPM2B_NONCE*)&(source->nonce), buffer, size));
    result = (UINT16)(result
                      + TPMA_SESSION_Marshal(
                          (TPMA_SESSION*)&(source->sessionAttributes), buffer, size));
    result =
        (UINT16)(result
                 + TPM2B_AUTH_Marshal((TPM2B_AUTH*)&(source->hmac), buffer, size));
    return result;
}

///////////////////////////////////////////////////////////////////////////////
//                           ###    ########  ######
//                          ## ##   ##       ##    ##
//                         ##   ##  ##       ##
//                        ##     ## ######    ######
//                        ######### ##             ##
//                        ##     ## ##       ##    ##
//                        ##     ## ########  ######
///////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMI_AES_KEY_BITS Type" (Part 2: Structures)
#  if ALG_AES
TPM_RC
TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_KEY_BITS_Unmarshal((TPM_KEY_BITS*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if AES_128
            case 128:
#    endif  // AES_128
#    if AES_192
            case 192:
#    endif  // AES_192
#    if AES_256
            case 256:
#    endif  // AES_256
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
#  endif  // ALG_AES

// Table "Definition of TPMI_SM4_KEY_BITS Type" (Part 2: Structures)
#  if ALG_SM4
TPM_RC
TPMI_SM4_KEY_BITS_Unmarshal(TPMI_SM4_KEY_BITS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_KEY_BITS_Unmarshal((TPM_KEY_BITS*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if SM4_128
            case 128:
#    endif  // SM4_128
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
#  endif  // ALG_SM4

// Table "Definition of TPMI_CAMELLIA_KEY_BITS Type" (Part 2: Structures)
#  if ALG_CAMELLIA
TPM_RC
TPMI_CAMELLIA_KEY_BITS_Unmarshal(
    TPMI_CAMELLIA_KEY_BITS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_KEY_BITS_Unmarshal((TPM_KEY_BITS*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if CAMELLIA_128
            case 128:
#    endif  // CAMELLIA_128
#    if CAMELLIA_192
            case 192:
#    endif  // CAMELLIA_192
#    if CAMELLIA_256
            case 256:
#    endif  // CAMELLIA_256
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
#  endif  // ALG_CAMELLIA

// Table "Definition of TPMU_SYM_KEY_BITS Union" (Part 2: Structures)
TPM_RC
TPMU_SYM_KEY_BITS_Unmarshal(
    TPMU_SYM_KEY_BITS* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_AES
        case TPM_ALG_AES:
            return TPMI_AES_KEY_BITS_Unmarshal(
                (TPMI_AES_KEY_BITS*)&(target->aes), buffer, size);
#  endif  // ALG_AES
#  if ALG_SM4
        case TPM_ALG_SM4:
            return TPMI_SM4_KEY_BITS_Unmarshal(
                (TPMI_SM4_KEY_BITS*)&(target->sm4), buffer, size);
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
        case TPM_ALG_CAMELLIA:
            return TPMI_CAMELLIA_KEY_BITS_Unmarshal(
                (TPMI_CAMELLIA_KEY_BITS*)&(target->camellia), buffer, size);
#  endif  // ALG_CAMELLIA
#  if ALG_XOR
        case TPM_ALG_XOR:
            return TPMI_ALG_HASH_Unmarshal(
                (TPMI_ALG_HASH*)&(target->xor), buffer, size, 0);
#  endif  // ALG_XOR
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SYM_KEY_BITS_Marshal(
    TPMU_SYM_KEY_BITS* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_AES
        case TPM_ALG_AES:
            return TPMI_AES_KEY_BITS_Marshal(
                (TPMI_AES_KEY_BITS*)&(source->aes), buffer, size);
#  endif  // ALG_AES
#  if ALG_SM4
        case TPM_ALG_SM4:
            return TPMI_SM4_KEY_BITS_Marshal(
                (TPMI_SM4_KEY_BITS*)&(source->sm4), buffer, size);
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
        case TPM_ALG_CAMELLIA:
            return TPMI_CAMELLIA_KEY_BITS_Marshal(
                (TPMI_CAMELLIA_KEY_BITS*)&(source->camellia), buffer, size);
#  endif  // ALG_CAMELLIA
#  if ALG_XOR
        case TPM_ALG_XOR:
            return TPMI_ALG_HASH_Marshal(
                (TPMI_ALG_HASH*)&(source->xor), buffer, size);
#  endif  // ALG_XOR
    }
    return 0;
}

// Table "Definition of TPMU_SYM_MODE Union" (Part 2: Structures)
TPM_RC
TPMU_SYM_MODE_Unmarshal(
    TPMU_SYM_MODE* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_AES
        case TPM_ALG_AES:
            return TPMI_ALG_SYM_MODE_Unmarshal(
                (TPMI_ALG_SYM_MODE*)&(target->aes), buffer, size, 1);
#  endif  // ALG_AES
#  if ALG_SM4
        case TPM_ALG_SM4:
            return TPMI_ALG_SYM_MODE_Unmarshal(
                (TPMI_ALG_SYM_MODE*)&(target->sm4), buffer, size, 1);
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
        case TPM_ALG_CAMELLIA:
            return TPMI_ALG_SYM_MODE_Unmarshal(
                (TPMI_ALG_SYM_MODE*)&(target->camellia), buffer, size, 1);
#  endif  // ALG_CAMELLIA
#  if ALG_XOR
        case TPM_ALG_XOR:
            return TPM_RC_SUCCESS;
#  endif  // ALG_XOR
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SYM_MODE_Marshal(
    TPMU_SYM_MODE* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_AES
        case TPM_ALG_AES:
            return TPMI_ALG_SYM_MODE_Marshal(
                (TPMI_ALG_SYM_MODE*)&(source->aes), buffer, size);
#  endif  // ALG_AES
#  if ALG_SM4
        case TPM_ALG_SM4:
            return TPMI_ALG_SYM_MODE_Marshal(
                (TPMI_ALG_SYM_MODE*)&(source->sm4), buffer, size);
#  endif  // ALG_SM4
#  if ALG_CAMELLIA
        case TPM_ALG_CAMELLIA:
            return TPMI_ALG_SYM_MODE_Marshal(
                (TPMI_ALG_SYM_MODE*)&(source->camellia), buffer, size);
#  endif  // ALG_CAMELLIA
    }
    return 0;
}

// Table "Definition of TPMT_SYM_DEF Structure" (Part 2: Structures)
TPM_RC
TPMT_SYM_DEF_Unmarshal(TPMT_SYM_DEF* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_SYM_Unmarshal(
        (TPMI_ALG_SYM*)&(target->algorithm), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SYM_KEY_BITS_Unmarshal((TPMU_SYM_KEY_BITS*)&(target->keyBits),
                                             buffer,
                                             size,
                                             (UINT32)target->algorithm);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SYM_MODE_Unmarshal(
            (TPMU_SYM_MODE*)&(target->mode), buffer, size, (UINT32)target->algorithm);
    return result;
}
UINT16
TPMT_SYM_DEF_Marshal(TPMT_SYM_DEF* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_SYM_Marshal(
                          (TPMI_ALG_SYM*)&(source->algorithm), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_SYM_KEY_BITS_Marshal((TPMU_SYM_KEY_BITS*)&(source->keyBits),
                                             buffer,
                                             size,
                                             (UINT32)source->algorithm));
    result = (UINT16)(result
                      + TPMU_SYM_MODE_Marshal((TPMU_SYM_MODE*)&(source->mode),
                                              buffer,
                                              size,
                                              (UINT32)source->algorithm));
    return result;
}

// Table "Definition of TPMT_SYM_DEF_OBJECT Structure" (Part 2: Structures)
TPM_RC
TPMT_SYM_DEF_OBJECT_Unmarshal(
    TPMT_SYM_DEF_OBJECT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_SYM_OBJECT_Unmarshal(
        (TPMI_ALG_SYM_OBJECT*)&(target->algorithm), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SYM_KEY_BITS_Unmarshal((TPMU_SYM_KEY_BITS*)&(target->keyBits),
                                             buffer,
                                             size,
                                             (UINT32)target->algorithm);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SYM_MODE_Unmarshal(
            (TPMU_SYM_MODE*)&(target->mode), buffer, size, (UINT32)target->algorithm);
    return result;
}
UINT16
TPMT_SYM_DEF_OBJECT_Marshal(TPMT_SYM_DEF_OBJECT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_SYM_OBJECT_Marshal(
                          (TPMI_ALG_SYM_OBJECT*)&(source->algorithm), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_SYM_KEY_BITS_Marshal((TPMU_SYM_KEY_BITS*)&(source->keyBits),
                                             buffer,
                                             size,
                                             (UINT32)source->algorithm));
    result = (UINT16)(result
                      + TPMU_SYM_MODE_Marshal((TPMU_SYM_MODE*)&(source->mode),
                                              buffer,
                                              size,
                                              (UINT32)source->algorithm));
    return result;
}

// Table "Definition of TPM2B_SYM_KEY Structure" (Part 2: Structures)
TPM_RC
TPM2B_SYM_KEY_Unmarshal(TPM2B_SYM_KEY* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_SYM_KEY_BYTES))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_SYM_KEY_Marshal(TPM2B_SYM_KEY* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_SYMCIPHER_PARMS Structure" (Part 2: Structures)
TPM_RC
TPMS_SYMCIPHER_PARMS_Unmarshal(
    TPMS_SYMCIPHER_PARMS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMT_SYM_DEF_OBJECT_Unmarshal(
        (TPMT_SYM_DEF_OBJECT*)&(target->sym), buffer, size, 0);
    return result;
}
UINT16
TPMS_SYMCIPHER_PARMS_Marshal(TPMS_SYMCIPHER_PARMS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMT_SYM_DEF_OBJECT_Marshal(
                          (TPMT_SYM_DEF_OBJECT*)&(source->sym), buffer, size));
    return result;
}

// Table "Definition of TPM2B_LABEL Structure" (Part 2: Structures)
TPM_RC
TPM2B_LABEL_Unmarshal(TPM2B_LABEL* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > LABEL_MAX_BUFFER))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_LABEL_Marshal(TPM2B_LABEL* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_DERIVE Structure" (Part 2: Structures)
TPM_RC
TPMS_DERIVE_Unmarshal(TPMS_DERIVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM2B_LABEL_Unmarshal((TPM2B_LABEL*)&(target->label), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_LABEL_Unmarshal((TPM2B_LABEL*)&(target->context), buffer, size);
    return result;
}
UINT16
TPMS_DERIVE_Marshal(TPMS_DERIVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPM2B_LABEL_Marshal((TPM2B_LABEL*)&(source->label), buffer, size));
    result = (UINT16)(result
                      + TPM2B_LABEL_Marshal(
                          (TPM2B_LABEL*)&(source->context), buffer, size));
    return result;
}

// Table "Definition of TPM2B_DERIVE Structure" (Part 2: Structures)
TPM_RC
TPM2B_DERIVE_Unmarshal(TPM2B_DERIVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMS_DERIVE)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_DERIVE_Marshal(TPM2B_DERIVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_SENSITIVE_DATA Structure" (Part 2: Structures)
TPM_RC
TPM2B_SENSITIVE_DATA_Unmarshal(
    TPM2B_SENSITIVE_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMU_SENSITIVE_CREATE)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_SENSITIVE_DATA_Marshal(TPM2B_SENSITIVE_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_SENSITIVE_CREATE Structure" (Part 2: Structures)
TPM_RC
TPMS_SENSITIVE_CREATE_Unmarshal(
    TPMS_SENSITIVE_CREATE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM2B_AUTH_Unmarshal((TPM2B_AUTH*)&(target->userAuth), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_SENSITIVE_DATA_Unmarshal(
            (TPM2B_SENSITIVE_DATA*)&(target->data), buffer, size);
    return result;
}

// Table "Definition of TPM2B_SENSITIVE_CREATE Structure" (Part 2: Structures)
TPM_RC
TPM2B_SENSITIVE_CREATE_Unmarshal(
    TPM2B_SENSITIVE_CREATE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMS_SENSITIVE_CREATE_Unmarshal(
                (TPMS_SENSITIVE_CREATE*)&(target->sensitive), buffer, size);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}

// Table "Definition of TPMS_SCHEME_HASH Structure" (Part 2: Structures)
TPM_RC
TPMS_SCHEME_HASH_Unmarshal(TPMS_SCHEME_HASH* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hashAlg), buffer, size, 0);
    return result;
}
UINT16
TPMS_SCHEME_HASH_Marshal(TPMS_SCHEME_HASH* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hashAlg), buffer, size));
    return result;
}

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
///////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMS_SCHEME_ECDAA Structure" (Part 2: Structures)
#  if ALG_ECC
TPM_RC
TPMS_SCHEME_ECDAA_Unmarshal(TPMS_SCHEME_ECDAA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hashAlg), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = UINT16_Unmarshal((UINT16*)&(target->count), buffer, size);
    return result;
}
UINT16
TPMS_SCHEME_ECDAA_Marshal(TPMS_SCHEME_ECDAA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hashAlg), buffer, size));
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->count), buffer, size));
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPMI_ALG_KEYEDHASH_SCHEME Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal(
    TPMI_ALG_KEYEDHASH_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_HMAC
            case TPM_ALG_HMAC:
#  endif  // ALG_HMAC
#  if ALG_XOR
            case TPM_ALG_XOR:
#  endif  // ALG_XOR
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMS_SCHEME_XOR Structure" (Part 2: Structures)
TPM_RC
TPMS_SCHEME_XOR_Unmarshal(TPMS_SCHEME_XOR* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hashAlg), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result =
            TPMI_ALG_KDF_Unmarshal((TPMI_ALG_KDF*)&(target->kdf), buffer, size, 1);
    return result;
}
UINT16
TPMS_SCHEME_XOR_Marshal(TPMS_SCHEME_XOR* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hashAlg), buffer, size));
    result =
        (UINT16)(result
                 + TPMI_ALG_KDF_Marshal((TPMI_ALG_KDF*)&(source->kdf), buffer, size));
    return result;
}

// Table "Definition of TPMU_SCHEME_KEYEDHASH Union" (Part 2: Structures)
TPM_RC
TPMU_SCHEME_KEYEDHASH_Unmarshal(
    TPMU_SCHEME_KEYEDHASH* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMS_SCHEME_HMAC_Unmarshal(
                (TPMS_SCHEME_HMAC*)&(target->hmac), buffer, size);
#  endif  // ALG_HMAC
#  if ALG_XOR
        case TPM_ALG_XOR:
            return TPMS_SCHEME_XOR_Unmarshal(
                (TPMS_SCHEME_XOR*)&(target->xor), buffer, size);
#  endif  // ALG_XOR
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SCHEME_KEYEDHASH_Marshal(
    TPMU_SCHEME_KEYEDHASH* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMS_SCHEME_HMAC_Marshal(
                (TPMS_SCHEME_HMAC*)&(source->hmac), buffer, size);
#  endif  // ALG_HMAC
#  if ALG_XOR
        case TPM_ALG_XOR:
            return TPMS_SCHEME_XOR_Marshal(
                (TPMS_SCHEME_XOR*)&(source->xor), buffer, size);
#  endif  // ALG_XOR
    }
    return 0;
}

// Table "Definition of TPMT_KEYEDHASH_SCHEME Structure" (Part 2: Structures)
TPM_RC
TPMT_KEYEDHASH_SCHEME_Unmarshal(
    TPMT_KEYEDHASH_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal(
        (TPMI_ALG_KEYEDHASH_SCHEME*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SCHEME_KEYEDHASH_Unmarshal(
            (TPMU_SCHEME_KEYEDHASH*)&(target->details),
            buffer,
            size,
            (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_KEYEDHASH_SCHEME_Marshal(
    TPMT_KEYEDHASH_SCHEME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPMI_ALG_KEYEDHASH_SCHEME_Marshal(
                     (TPMI_ALG_KEYEDHASH_SCHEME*)&(source->scheme), buffer, size));
    result = (UINT16)(result
                      + TPMU_SCHEME_KEYEDHASH_Marshal(
                          (TPMU_SCHEME_KEYEDHASH*)&(source->details),
                          buffer,
                          size,
                          (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPMU_SIG_SCHEME Union" (Part 2: Structures)
TPM_RC
TPMU_SIG_SCHEME_Unmarshal(
    TPMU_SIG_SCHEME* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMS_SCHEME_HMAC_Unmarshal(
                (TPMS_SCHEME_HMAC*)&(target->hmac), buffer, size);
#  endif  // ALG_HMAC
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIG_SCHEME_RSASSA_Unmarshal(
                (TPMS_SIG_SCHEME_RSASSA*)&(target->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIG_SCHEME_RSAPSS_Unmarshal(
                (TPMS_SIG_SCHEME_RSAPSS*)&(target->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIG_SCHEME_ECDSA_Unmarshal(
                (TPMS_SIG_SCHEME_ECDSA*)&(target->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIG_SCHEME_ECDAA_Unmarshal(
                (TPMS_SIG_SCHEME_ECDAA*)&(target->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_SIG_SCHEME_SM2_Unmarshal(
                (TPMS_SIG_SCHEME_SM2*)&(target->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIG_SCHEME_ECSCHNORR_Unmarshal(
                (TPMS_SIG_SCHEME_ECSCHNORR*)&(target->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIG_SCHEME_EDDSA_Unmarshal(
                (TPMS_SIG_SCHEME_EDDSA*)&(target->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIG_SCHEME_EDDSA_PH_Unmarshal(
                (TPMS_SIG_SCHEME_EDDSA_PH*)&(target->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIG_SCHEME_LMS_Unmarshal(
                (TPMS_SIG_SCHEME_LMS*)&(target->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIG_SCHEME_XMSS_Unmarshal(
                (TPMS_SIG_SCHEME_XMSS*)&(target->xmss), buffer, size);
#  endif  // ALG_XMSS
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SIG_SCHEME_Marshal(
    TPMU_SIG_SCHEME* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMS_SCHEME_HMAC_Marshal(
                (TPMS_SCHEME_HMAC*)&(source->hmac), buffer, size);
#  endif  // ALG_HMAC
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIG_SCHEME_RSASSA_Marshal(
                (TPMS_SIG_SCHEME_RSASSA*)&(source->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIG_SCHEME_RSAPSS_Marshal(
                (TPMS_SIG_SCHEME_RSAPSS*)&(source->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIG_SCHEME_ECDSA_Marshal(
                (TPMS_SIG_SCHEME_ECDSA*)&(source->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIG_SCHEME_ECDAA_Marshal(
                (TPMS_SIG_SCHEME_ECDAA*)&(source->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_SIG_SCHEME_SM2_Marshal(
                (TPMS_SIG_SCHEME_SM2*)&(source->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIG_SCHEME_ECSCHNORR_Marshal(
                (TPMS_SIG_SCHEME_ECSCHNORR*)&(source->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIG_SCHEME_EDDSA_Marshal(
                (TPMS_SIG_SCHEME_EDDSA*)&(source->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIG_SCHEME_EDDSA_PH_Marshal(
                (TPMS_SIG_SCHEME_EDDSA_PH*)&(source->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIG_SCHEME_LMS_Marshal(
                (TPMS_SIG_SCHEME_LMS*)&(source->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIG_SCHEME_XMSS_Marshal(
                (TPMS_SIG_SCHEME_XMSS*)&(source->xmss), buffer, size);
#  endif  // ALG_XMSS
    }
    return 0;
}

// Table "Definition of TPMT_SIG_SCHEME Structure" (Part 2: Structures)
TPM_RC
TPMT_SIG_SCHEME_Unmarshal(
    TPMT_SIG_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_SIG_SCHEME_Unmarshal(
        (TPMI_ALG_SIG_SCHEME*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SIG_SCHEME_Unmarshal((TPMU_SIG_SCHEME*)&(target->details),
                                           buffer,
                                           size,
                                           (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_SIG_SCHEME_Marshal(TPMT_SIG_SCHEME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_SIG_SCHEME_Marshal(
                          (TPMI_ALG_SIG_SCHEME*)&(source->scheme), buffer, size));
    result        = (UINT16)(result
                      + TPMU_SIG_SCHEME_Marshal((TPMU_SIG_SCHEME*)&(source->details),
                                                buffer,
                                                size,
                                                (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPMU_KDF_SCHEME Union" (Part 2: Structures)
TPM_RC
TPMU_KDF_SCHEME_Unmarshal(
    TPMU_KDF_SCHEME* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_MGF1
        case TPM_ALG_MGF1:
            return TPMS_KDF_SCHEME_MGF1_Unmarshal(
                (TPMS_KDF_SCHEME_MGF1*)&(target->mgf1), buffer, size);
#  endif  // ALG_MGF1
#  if ALG_KDF1_SP800_56A
        case TPM_ALG_KDF1_SP800_56A:
            return TPMS_KDF_SCHEME_KDF1_SP800_56A_Unmarshal(
                (TPMS_KDF_SCHEME_KDF1_SP800_56A*)&(target->kdf1_sp800_56a),
                buffer,
                size);
#  endif  // ALG_KDF1_SP800_56A
#  if ALG_KDF2
        case TPM_ALG_KDF2:
            return TPMS_KDF_SCHEME_KDF2_Unmarshal(
                (TPMS_KDF_SCHEME_KDF2*)&(target->kdf2), buffer, size);
#  endif  // ALG_KDF2
#  if ALG_KDF1_SP800_108
        case TPM_ALG_KDF1_SP800_108:
            return TPMS_KDF_SCHEME_KDF1_SP800_108_Unmarshal(
                (TPMS_KDF_SCHEME_KDF1_SP800_108*)&(target->kdf1_sp800_108),
                buffer,
                size);
#  endif  // ALG_KDF1_SP800_108
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_KDF_SCHEME_Marshal(
    TPMU_KDF_SCHEME* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_MGF1
        case TPM_ALG_MGF1:
            return TPMS_KDF_SCHEME_MGF1_Marshal(
                (TPMS_KDF_SCHEME_MGF1*)&(source->mgf1), buffer, size);
#  endif  // ALG_MGF1
#  if ALG_KDF1_SP800_56A
        case TPM_ALG_KDF1_SP800_56A:
            return TPMS_KDF_SCHEME_KDF1_SP800_56A_Marshal(
                (TPMS_KDF_SCHEME_KDF1_SP800_56A*)&(source->kdf1_sp800_56a),
                buffer,
                size);
#  endif  // ALG_KDF1_SP800_56A
#  if ALG_KDF2
        case TPM_ALG_KDF2:
            return TPMS_KDF_SCHEME_KDF2_Marshal(
                (TPMS_KDF_SCHEME_KDF2*)&(source->kdf2), buffer, size);
#  endif  // ALG_KDF2
#  if ALG_KDF1_SP800_108
        case TPM_ALG_KDF1_SP800_108:
            return TPMS_KDF_SCHEME_KDF1_SP800_108_Marshal(
                (TPMS_KDF_SCHEME_KDF1_SP800_108*)&(source->kdf1_sp800_108),
                buffer,
                size);
#  endif  // ALG_KDF1_SP800_108
    }
    return 0;
}

// Table "Definition of TPMT_KDF_SCHEME Structure" (Part 2: Structures)
TPM_RC
TPMT_KDF_SCHEME_Unmarshal(
    TPMT_KDF_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result =
        TPMI_ALG_KDF_Unmarshal((TPMI_ALG_KDF*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_KDF_SCHEME_Unmarshal((TPMU_KDF_SCHEME*)&(target->details),
                                           buffer,
                                           size,
                                           (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_KDF_SCHEME_Marshal(TPMT_KDF_SCHEME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_KDF_Marshal(
                          (TPMI_ALG_KDF*)&(source->scheme), buffer, size));
    result        = (UINT16)(result
                      + TPMU_KDF_SCHEME_Marshal((TPMU_KDF_SCHEME*)&(source->details),
                                                buffer,
                                                size,
                                                (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPMI_ALG_ASYM_SCHEME Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_ASYM_SCHEME_Unmarshal(
    TPMI_ALG_ASYM_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_RSASSA
            case TPM_ALG_RSASSA:
#  endif  // ALG_RSASSA
#  if ALG_RSAES
            case TPM_ALG_RSAES:
#  endif  // ALG_RSAES
#  if ALG_RSAPSS
            case TPM_ALG_RSAPSS:
#  endif  // ALG_RSAPSS
#  if ALG_OAEP
            case TPM_ALG_OAEP:
#  endif  // ALG_OAEP
#  if ALG_ECDSA
            case TPM_ALG_ECDSA:
#  endif  // ALG_ECDSA
#  if ALG_ECDH
            case TPM_ALG_ECDH:
#  endif  // ALG_ECDH
#  if ALG_ECDAA
            case TPM_ALG_ECDAA:
#  endif  // ALG_ECDAA
#  if ALG_SM2
            case TPM_ALG_SM2:
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
            case TPM_ALG_ECSCHNORR:
#  endif  // ALG_ECSCHNORR
#  if ALG_ECMQV
            case TPM_ALG_ECMQV:
#  endif  // ALG_ECMQV
#  if ALG_EDDSA
            case TPM_ALG_EDDSA:
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
            case TPM_ALG_EDDSA_PH:
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
            case TPM_ALG_LMS:
#  endif  // ALG_LMS
#  if ALG_XMSS
            case TPM_ALG_XMSS:
#  endif  // ALG_XMSS
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMU_ASYM_SCHEME Union" (Part 2: Structures)
TPM_RC
TPMU_ASYM_SCHEME_Unmarshal(
    TPMU_ASYM_SCHEME* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIG_SCHEME_RSASSA_Unmarshal(
                (TPMS_SIG_SCHEME_RSASSA*)&(target->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAES
        case TPM_ALG_RSAES:
            return TPMS_ENC_SCHEME_RSAES_Unmarshal(
                (TPMS_ENC_SCHEME_RSAES*)&(target->rsaes), buffer, size);
#  endif  // ALG_RSAES
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIG_SCHEME_RSAPSS_Unmarshal(
                (TPMS_SIG_SCHEME_RSAPSS*)&(target->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_OAEP
        case TPM_ALG_OAEP:
            return TPMS_ENC_SCHEME_OAEP_Unmarshal(
                (TPMS_ENC_SCHEME_OAEP*)&(target->oaep), buffer, size);
#  endif  // ALG_OAEP
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIG_SCHEME_ECDSA_Unmarshal(
                (TPMS_SIG_SCHEME_ECDSA*)&(target->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDH
        case TPM_ALG_ECDH:
            return TPMS_KEY_SCHEME_ECDH_Unmarshal(
                (TPMS_KEY_SCHEME_ECDH*)&(target->ecdh), buffer, size);
#  endif  // ALG_ECDH
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIG_SCHEME_ECDAA_Unmarshal(
                (TPMS_SIG_SCHEME_ECDAA*)&(target->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_KEY_SCHEME_SM2_Unmarshal(
                (TPMS_KEY_SCHEME_SM2*)&(target->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIG_SCHEME_ECSCHNORR_Unmarshal(
                (TPMS_SIG_SCHEME_ECSCHNORR*)&(target->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_ECMQV
        case TPM_ALG_ECMQV:
            return TPMS_KEY_SCHEME_ECMQV_Unmarshal(
                (TPMS_KEY_SCHEME_ECMQV*)&(target->ecmqv), buffer, size);
#  endif  // ALG_ECMQV
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIG_SCHEME_EDDSA_Unmarshal(
                (TPMS_SIG_SCHEME_EDDSA*)&(target->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIG_SCHEME_EDDSA_PH_Unmarshal(
                (TPMS_SIG_SCHEME_EDDSA_PH*)&(target->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIG_SCHEME_LMS_Unmarshal(
                (TPMS_SIG_SCHEME_LMS*)&(target->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIG_SCHEME_XMSS_Unmarshal(
                (TPMS_SIG_SCHEME_XMSS*)&(target->xmss), buffer, size);
#  endif  // ALG_XMSS
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_ASYM_SCHEME_Marshal(
    TPMU_ASYM_SCHEME* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIG_SCHEME_RSASSA_Marshal(
                (TPMS_SIG_SCHEME_RSASSA*)&(source->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAES
        case TPM_ALG_RSAES:
            return TPMS_ENC_SCHEME_RSAES_Marshal(
                (TPMS_ENC_SCHEME_RSAES*)&(source->rsaes), buffer, size);
#  endif  // ALG_RSAES
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIG_SCHEME_RSAPSS_Marshal(
                (TPMS_SIG_SCHEME_RSAPSS*)&(source->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_OAEP
        case TPM_ALG_OAEP:
            return TPMS_ENC_SCHEME_OAEP_Marshal(
                (TPMS_ENC_SCHEME_OAEP*)&(source->oaep), buffer, size);
#  endif  // ALG_OAEP
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIG_SCHEME_ECDSA_Marshal(
                (TPMS_SIG_SCHEME_ECDSA*)&(source->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDH
        case TPM_ALG_ECDH:
            return TPMS_KEY_SCHEME_ECDH_Marshal(
                (TPMS_KEY_SCHEME_ECDH*)&(source->ecdh), buffer, size);
#  endif  // ALG_ECDH
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIG_SCHEME_ECDAA_Marshal(
                (TPMS_SIG_SCHEME_ECDAA*)&(source->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_KEY_SCHEME_SM2_Marshal(
                (TPMS_KEY_SCHEME_SM2*)&(source->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIG_SCHEME_ECSCHNORR_Marshal(
                (TPMS_SIG_SCHEME_ECSCHNORR*)&(source->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_ECMQV
        case TPM_ALG_ECMQV:
            return TPMS_KEY_SCHEME_ECMQV_Marshal(
                (TPMS_KEY_SCHEME_ECMQV*)&(source->ecmqv), buffer, size);
#  endif  // ALG_ECMQV
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIG_SCHEME_EDDSA_Marshal(
                (TPMS_SIG_SCHEME_EDDSA*)&(source->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIG_SCHEME_EDDSA_PH_Marshal(
                (TPMS_SIG_SCHEME_EDDSA_PH*)&(source->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIG_SCHEME_LMS_Marshal(
                (TPMS_SIG_SCHEME_LMS*)&(source->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIG_SCHEME_XMSS_Marshal(
                (TPMS_SIG_SCHEME_XMSS*)&(source->xmss), buffer, size);
#  endif  // ALG_XMSS
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//                       ########   ######     ###
//                       ##     ## ##    ##   ## ##
//                       ##     ## ##        ##   ##
//                       ########   ######  ##     ##
//                       ##   ##         ## #########
//                       ##    ##  ##    ## ##     ##
//                       ##     ##  ######  ##     ##
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMI_ALG_RSA_SCHEME Type" (Part 2: Structures)
#  if ALG_RSA
TPM_RC
TPMI_ALG_RSA_SCHEME_Unmarshal(
    TPMI_ALG_RSA_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ALG_RSASSA
            case TPM_ALG_RSASSA:
#    endif  // ALG_RSASSA
#    if ALG_RSAES
            case TPM_ALG_RSAES:
#    endif  // ALG_RSAES
#    if ALG_RSAPSS
            case TPM_ALG_RSAPSS:
#    endif  // ALG_RSAPSS
#    if ALG_OAEP
            case TPM_ALG_OAEP:
#    endif  // ALG_OAEP
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMT_RSA_SCHEME Structure" (Part 2: Structures)
TPM_RC
TPMT_RSA_SCHEME_Unmarshal(
    TPMT_RSA_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_RSA_SCHEME_Unmarshal(
        (TPMI_ALG_RSA_SCHEME*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_ASYM_SCHEME_Unmarshal((TPMU_ASYM_SCHEME*)&(target->details),
                                            buffer,
                                            size,
                                            (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_RSA_SCHEME_Marshal(TPMT_RSA_SCHEME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_RSA_SCHEME_Marshal(
                          (TPMI_ALG_RSA_SCHEME*)&(source->scheme), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_ASYM_SCHEME_Marshal((TPMU_ASYM_SCHEME*)&(source->details),
                                            buffer,
                                            size,
                                            (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPMI_ALG_RSA_DECRYPT Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_RSA_DECRYPT_Unmarshal(
    TPMI_ALG_RSA_DECRYPT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ALG_RSAES
            case TPM_ALG_RSAES:
#    endif  // ALG_RSAES
#    if ALG_OAEP
            case TPM_ALG_OAEP:
#    endif  // ALG_OAEP
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMT_RSA_DECRYPT Structure" (Part 2: Structures)
TPM_RC
TPMT_RSA_DECRYPT_Unmarshal(
    TPMT_RSA_DECRYPT* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_RSA_DECRYPT_Unmarshal(
        (TPMI_ALG_RSA_DECRYPT*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_ASYM_SCHEME_Unmarshal((TPMU_ASYM_SCHEME*)&(target->details),
                                            buffer,
                                            size,
                                            (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_RSA_DECRYPT_Marshal(TPMT_RSA_DECRYPT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_RSA_DECRYPT_Marshal(
                          (TPMI_ALG_RSA_DECRYPT*)&(source->scheme), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_ASYM_SCHEME_Marshal((TPMU_ASYM_SCHEME*)&(source->details),
                                            buffer,
                                            size,
                                            (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPM2B_PUBLIC_KEY_RSA Structure" (Part 2: Structures)
TPM_RC
TPM2B_PUBLIC_KEY_RSA_Unmarshal(
    TPM2B_PUBLIC_KEY_RSA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_RSA_KEY_BYTES))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_PUBLIC_KEY_RSA_Marshal(TPM2B_PUBLIC_KEY_RSA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMI_RSA_KEY_BITS Type" (Part 2: Structures)
TPM_RC
TPMI_RSA_KEY_BITS_Unmarshal(TPMI_RSA_KEY_BITS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_KEY_BITS_Unmarshal((TPM_KEY_BITS*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if RSA_1024
            case 1024:
#    endif  // RSA_1024
#    if RSA_2048
            case 2048:
#    endif  // RSA_2048
#    if RSA_3072
            case 3072:
#    endif  // RSA_3072
#    if RSA_4096
            case 4096:
#    endif  // RSA_4096
#    if RSA_16384
            case 16384:
#    endif  // RSA_16384
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPM2B_PRIVATE_KEY_RSA Structure" (Part 2: Structures)
TPM_RC
TPM2B_PRIVATE_KEY_RSA_Unmarshal(
    TPM2B_PRIVATE_KEY_RSA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > RSA_PRIVATE_SIZE))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_PRIVATE_KEY_RSA_Marshal(
    TPM2B_PRIVATE_KEY_RSA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}
#  endif  // ALG_RSA

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPM2B_ECC_PARAMETER Structure" (Part 2: Structures)
#  if ALG_ECC
TPM_RC
TPM2B_ECC_PARAMETER_Unmarshal(TPM2B_ECC_PARAMETER* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_ECC_KEY_BYTES))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_ECC_PARAMETER_Marshal(TPM2B_ECC_PARAMETER* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_ECC_POINT Structure" (Part 2: Structures)
TPM_RC
TPMS_ECC_POINT_Unmarshal(TPMS_ECC_POINT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM2B_ECC_PARAMETER_Unmarshal(
        (TPM2B_ECC_PARAMETER*)&(target->x), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_ECC_PARAMETER_Unmarshal(
            (TPM2B_ECC_PARAMETER*)&(target->y), buffer, size);
    return result;
}
UINT16
TPMS_ECC_POINT_Marshal(TPMS_ECC_POINT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->x), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->y), buffer, size));
    return result;
}

// Table "Definition of TPM2B_ECC_POINT Structure" (Part 2: Structures)
TPM_RC
TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMS_ECC_POINT_Unmarshal(
                (TPMS_ECC_POINT*)&(target->point), buffer, size);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}
UINT16
TPM2B_ECC_POINT_Marshal(TPM2B_ECC_POINT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result = (UINT16)(result
                      + TPMS_ECC_POINT_Marshal(
                          (TPMS_ECC_POINT*)&(source->point), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPMI_ALG_ECC_SCHEME Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_ECC_SCHEME_Unmarshal(
    TPMI_ALG_ECC_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ALG_ECDSA
            case TPM_ALG_ECDSA:
#    endif  // ALG_ECDSA
#    if ALG_ECDH
            case TPM_ALG_ECDH:
#    endif  // ALG_ECDH
#    if ALG_ECDAA
            case TPM_ALG_ECDAA:
#    endif  // ALG_ECDAA
#    if ALG_SM2
            case TPM_ALG_SM2:
#    endif  // ALG_SM2
#    if ALG_ECSCHNORR
            case TPM_ALG_ECSCHNORR:
#    endif  // ALG_ECSCHNORR
#    if ALG_ECMQV
            case TPM_ALG_ECMQV:
#    endif  // ALG_ECMQV
#    if ALG_EDDSA
            case TPM_ALG_EDDSA:
#    endif  // ALG_EDDSA
#    if ALG_EDDSA_PH
            case TPM_ALG_EDDSA_PH:
#    endif  // ALG_EDDSA_PH
                break;
            default:
                if((*target != TPM_ALG_NULL) || !flag)
                    result = TPM_RC_SCHEME;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMI_ECC_CURVE Type" (Part 2: Structures)
TPM_RC
TPMI_ECC_CURVE_Unmarshal(
    TPMI_ECC_CURVE* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPM_ECC_CURVE_Unmarshal((TPM_ECC_CURVE*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#    if ECC_NIST_P192
            case TPM_ECC_NIST_P192:
#    endif  // ECC_NIST_P192
#    if ECC_NIST_P224
            case TPM_ECC_NIST_P224:
#    endif  // ECC_NIST_P224
#    if ECC_NIST_P256
            case TPM_ECC_NIST_P256:
#    endif  // ECC_NIST_P256
#    if ECC_NIST_P384
            case TPM_ECC_NIST_P384:
#    endif  // ECC_NIST_P384
#    if ECC_NIST_P521
            case TPM_ECC_NIST_P521:
#    endif  // ECC_NIST_P521
#    if ECC_BN_P256
            case TPM_ECC_BN_P256:
#    endif  // ECC_BN_P256
#    if ECC_BN_P638
            case TPM_ECC_BN_P638:
#    endif  // ECC_BN_P638
#    if ECC_SM2_P256
            case TPM_ECC_SM2_P256:
#    endif  // ECC_SM2_P256
#    if ECC_BP_P256_R1
            case TPM_ECC_BP_P256_R1:
#    endif  // ECC_BP_P256_R1
#    if ECC_BP_P384_R1
            case TPM_ECC_BP_P384_R1:
#    endif  // ECC_BP_P384_R1
#    if ECC_BP_P512_R1
            case TPM_ECC_BP_P512_R1:
#    endif  // ECC_BP_P512_R1
#    if ECC_CURVE_25519
            case TPM_ECC_CURVE_25519:
#    endif  // ECC_CURVE_25519
#    if ECC_CURVE_448
            case TPM_ECC_CURVE_448:
#    endif  // ECC_CURVE_448
                break;
            default:
                if((*target != TPM_ECC_NONE) || !flag)
                    result = TPM_RC_CURVE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMT_ECC_SCHEME Structure" (Part 2: Structures)
TPM_RC
TPMT_ECC_SCHEME_Unmarshal(
    TPMT_ECC_SCHEME* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_ECC_SCHEME_Unmarshal(
        (TPMI_ALG_ECC_SCHEME*)&(target->scheme), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_ASYM_SCHEME_Unmarshal((TPMU_ASYM_SCHEME*)&(target->details),
                                            buffer,
                                            size,
                                            (UINT32)target->scheme);
    return result;
}
UINT16
TPMT_ECC_SCHEME_Marshal(TPMT_ECC_SCHEME* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_ECC_SCHEME_Marshal(
                          (TPMI_ALG_ECC_SCHEME*)&(source->scheme), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_ASYM_SCHEME_Marshal((TPMU_ASYM_SCHEME*)&(source->details),
                                            buffer,
                                            size,
                                            (UINT32)source->scheme));
    return result;
}

// Table "Definition of TPMS_ALGORITHM_DETAIL_ECC Structure" (Part 2: Structures)
UINT16
TPMS_ALGORITHM_DETAIL_ECC_Marshal(
    TPMS_ALGORITHM_DETAIL_ECC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM_ECC_CURVE_Marshal(
                          (TPM_ECC_CURVE*)&(source->curveID), buffer, size));
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->keySize), buffer, size));
    result = (UINT16)(result
                      + TPMT_KDF_SCHEME_Marshal(
                          (TPMT_KDF_SCHEME*)&(source->kdf), buffer, size));
    result = (UINT16)(result
                      + TPMT_ECC_SCHEME_Marshal(
                          (TPMT_ECC_SCHEME*)&(source->sign), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->p), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->a), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->b), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->gX), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->gY), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->n), buffer, size));
    result = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->h), buffer, size));
    return result;
}
#  endif  // ALG_ECC

////////////////////////////////////////////////////////////////////////////////
//                       ########   ######     ###
//                       ##     ## ##    ##   ## ##
//                       ##     ## ##        ##   ##
//                       ########   ######  ##     ##
//                       ##   ##         ## #########
//                       ##    ##  ##    ## ##     ##
//                       ##     ##  ######  ##     ##
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMS_SIGNATURE_RSA Structure" (Part 2: Structures)
#  if ALG_RSA
TPM_RC
TPMS_SIGNATURE_RSA_Unmarshal(TPMS_SIGNATURE_RSA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hash), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_PUBLIC_KEY_RSA_Unmarshal(
            (TPM2B_PUBLIC_KEY_RSA*)&(target->sig), buffer, size);
    return result;
}
UINT16
TPMS_SIGNATURE_RSA_Marshal(TPMS_SIGNATURE_RSA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hash), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_PUBLIC_KEY_RSA_Marshal(
                          (TPM2B_PUBLIC_KEY_RSA*)&(source->sig), buffer, size));
    return result;
}
#  endif  // ALG_RSA

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMS_SIGNATURE_ECC Structure" (Part 2: Structures)
#  if ALG_ECC
TPM_RC
TPMS_SIGNATURE_ECC_Unmarshal(TPMS_SIGNATURE_ECC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH*)&(target->hash), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_ECC_PARAMETER_Unmarshal(
            (TPM2B_ECC_PARAMETER*)&(target->signatureR), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_ECC_PARAMETER_Unmarshal(
            (TPM2B_ECC_PARAMETER*)&(target->signatureS), buffer, size);
    return result;
}
UINT16
TPMS_SIGNATURE_ECC_Marshal(TPMS_SIGNATURE_ECC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->hash), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->signatureR), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_ECC_PARAMETER_Marshal(
                          (TPM2B_ECC_PARAMETER*)&(source->signatureS), buffer, size));
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPMU_SIGNATURE Union" (Part 2: Structures)
TPM_RC
TPMU_SIGNATURE_Unmarshal(
    TPMU_SIGNATURE* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMT_HA_Unmarshal((TPMT_HA*)&(target->hmac), buffer, size, 0);
#  endif  // ALG_HMAC
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIGNATURE_RSASSA_Unmarshal(
                (TPMS_SIGNATURE_RSASSA*)&(target->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIGNATURE_RSAPSS_Unmarshal(
                (TPMS_SIGNATURE_RSAPSS*)&(target->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIGNATURE_ECDSA_Unmarshal(
                (TPMS_SIGNATURE_ECDSA*)&(target->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIGNATURE_ECDAA_Unmarshal(
                (TPMS_SIGNATURE_ECDAA*)&(target->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_SIGNATURE_SM2_Unmarshal(
                (TPMS_SIGNATURE_SM2*)&(target->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIGNATURE_ECSCHNORR_Unmarshal(
                (TPMS_SIGNATURE_ECSCHNORR*)&(target->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIGNATURE_EDDSA_Unmarshal(
                (TPMS_SIGNATURE_EDDSA*)&(target->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIGNATURE_EDDSA_PH_Unmarshal(
                (TPMS_SIGNATURE_EDDSA_PH*)&(target->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIGNATURE_LMS_Unmarshal(
                (TPMS_SIGNATURE_LMS*)&(target->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIGNATURE_XMSS_Unmarshal(
                (TPMS_SIGNATURE_XMSS*)&(target->xmss), buffer, size);
#  endif  // ALG_XMSS
        case TPM_ALG_NULL:
            return TPM_RC_SUCCESS;
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SIGNATURE_Marshal(
    TPMU_SIGNATURE* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_HMAC
        case TPM_ALG_HMAC:
            return TPMT_HA_Marshal((TPMT_HA*)&(source->hmac), buffer, size);
#  endif  // ALG_HMAC
#  if ALG_RSASSA
        case TPM_ALG_RSASSA:
            return TPMS_SIGNATURE_RSASSA_Marshal(
                (TPMS_SIGNATURE_RSASSA*)&(source->rsassa), buffer, size);
#  endif  // ALG_RSASSA
#  if ALG_RSAPSS
        case TPM_ALG_RSAPSS:
            return TPMS_SIGNATURE_RSAPSS_Marshal(
                (TPMS_SIGNATURE_RSAPSS*)&(source->rsapss), buffer, size);
#  endif  // ALG_RSAPSS
#  if ALG_ECDSA
        case TPM_ALG_ECDSA:
            return TPMS_SIGNATURE_ECDSA_Marshal(
                (TPMS_SIGNATURE_ECDSA*)&(source->ecdsa), buffer, size);
#  endif  // ALG_ECDSA
#  if ALG_ECDAA
        case TPM_ALG_ECDAA:
            return TPMS_SIGNATURE_ECDAA_Marshal(
                (TPMS_SIGNATURE_ECDAA*)&(source->ecdaa), buffer, size);
#  endif  // ALG_ECDAA
#  if ALG_SM2
        case TPM_ALG_SM2:
            return TPMS_SIGNATURE_SM2_Marshal(
                (TPMS_SIGNATURE_SM2*)&(source->sm2), buffer, size);
#  endif  // ALG_SM2
#  if ALG_ECSCHNORR
        case TPM_ALG_ECSCHNORR:
            return TPMS_SIGNATURE_ECSCHNORR_Marshal(
                (TPMS_SIGNATURE_ECSCHNORR*)&(source->ecschnorr), buffer, size);
#  endif  // ALG_ECSCHNORR
#  if ALG_EDDSA
        case TPM_ALG_EDDSA:
            return TPMS_SIGNATURE_EDDSA_Marshal(
                (TPMS_SIGNATURE_EDDSA*)&(source->eddsa), buffer, size);
#  endif  // ALG_EDDSA
#  if ALG_EDDSA_PH
        case TPM_ALG_EDDSA_PH:
            return TPMS_SIGNATURE_EDDSA_PH_Marshal(
                (TPMS_SIGNATURE_EDDSA_PH*)&(source->eddsa_ph), buffer, size);
#  endif  // ALG_EDDSA_PH
#  if ALG_LMS
        case TPM_ALG_LMS:
            return TPMS_SIGNATURE_LMS_Marshal(
                (TPMS_SIGNATURE_LMS*)&(source->lms), buffer, size);
#  endif  // ALG_LMS
#  if ALG_XMSS
        case TPM_ALG_XMSS:
            return TPMS_SIGNATURE_XMSS_Marshal(
                (TPMS_SIGNATURE_XMSS*)&(source->xmss), buffer, size);
#  endif  // ALG_XMSS
    }
    return 0;
}

// Table "Definition of TPMT_SIGNATURE Structure" (Part 2: Structures)
TPM_RC
TPMT_SIGNATURE_Unmarshal(
    TPMT_SIGNATURE* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = TPMI_ALG_SIG_SCHEME_Unmarshal(
        (TPMI_ALG_SIG_SCHEME*)&(target->sigAlg), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SIGNATURE_Unmarshal((TPMU_SIGNATURE*)&(target->signature),
                                          buffer,
                                          size,
                                          (UINT32)target->sigAlg);
    return result;
}
UINT16
TPMT_SIGNATURE_Marshal(TPMT_SIGNATURE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_SIG_SCHEME_Marshal(
                          (TPMI_ALG_SIG_SCHEME*)&(source->sigAlg), buffer, size));
    result        = (UINT16)(result
                      + TPMU_SIGNATURE_Marshal((TPMU_SIGNATURE*)&(source->signature),
                                               buffer,
                                               size,
                                               (UINT32)source->sigAlg));
    return result;
}

// Table "Definition of TPMU_ENCRYPTED_SECRET Union" (Part 2: Structures)
TPM_RC
TPMU_ENCRYPTED_SECRET_Unmarshal(
    TPMU_ENCRYPTED_SECRET* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_ECC
        case TPM_ALG_ECC:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->ecc), buffer, size, (INT32)sizeof(TPMS_ECC_POINT));
#  endif  // ALG_ECC
#  if ALG_RSA
        case TPM_ALG_RSA:
            return BYTE_Array_Unmarshal(
                (BYTE*)&(target->rsa), buffer, size, (INT32)MAX_RSA_KEY_BYTES);
#  endif  // ALG_RSA
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return BYTE_Array_Unmarshal((BYTE*)&(target->symmetric),
                                        buffer,
                                        size,
                                        (INT32)sizeof(TPM2B_DIGEST));
#  endif  // ALG_SYMCIPHER
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return BYTE_Array_Unmarshal((BYTE*)&(target->keyedHash),
                                        buffer,
                                        size,
                                        (INT32)sizeof(TPM2B_DIGEST));
#  endif  // ALG_KEYEDHASH
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_ENCRYPTED_SECRET_Marshal(
    TPMU_ENCRYPTED_SECRET* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_ECC
        case TPM_ALG_ECC:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->ecc), buffer, size, (INT32)sizeof(TPMS_ECC_POINT));
#  endif  // ALG_ECC
#  if ALG_RSA
        case TPM_ALG_RSA:
            return BYTE_Array_Marshal(
                (BYTE*)&(source->rsa), buffer, size, (INT32)MAX_RSA_KEY_BYTES);
#  endif  // ALG_RSA
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return BYTE_Array_Marshal((BYTE*)&(source->symmetric),
                                      buffer,
                                      size,
                                      (INT32)sizeof(TPM2B_DIGEST));
#  endif  // ALG_SYMCIPHER
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return BYTE_Array_Marshal((BYTE*)&(source->keyedHash),
                                      buffer,
                                      size,
                                      (INT32)sizeof(TPM2B_DIGEST));
#  endif  // ALG_KEYEDHASH
    }
    return 0;
}

// Table "Definition of TPM2B_ENCRYPTED_SECRET Structure" (Part 2: Structures)
TPM_RC
TPM2B_ENCRYPTED_SECRET_Unmarshal(
    TPM2B_ENCRYPTED_SECRET* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMU_ENCRYPTED_SECRET)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.secret), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_ENCRYPTED_SECRET_Marshal(
    TPM2B_ENCRYPTED_SECRET* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.secret),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMI_ALG_PUBLIC Type" (Part 2: Structures)
TPM_RC
TPMI_ALG_PUBLIC_Unmarshal(TPMI_ALG_PUBLIC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_ALG_ID_Unmarshal((TPM_ALG_ID*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
#  if ALG_RSA
            case TPM_ALG_RSA:
#  endif  // ALG_RSA
#  if ALG_KEYEDHASH
            case TPM_ALG_KEYEDHASH:
#  endif  // ALG_KEYEDHASH
#  if ALG_ECC
            case TPM_ALG_ECC:
#  endif  // ALG_ECC
#  if ALG_SYMCIPHER
            case TPM_ALG_SYMCIPHER:
#  endif  // ALG_SYMCIPHER
                break;
            default:
                result = TPM_RC_TYPE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMU_PUBLIC_ID Union" (Part 2: Structures)
TPM_RC
TPMU_PUBLIC_ID_Unmarshal(
    TPMU_PUBLIC_ID* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPM2B_DIGEST_Unmarshal(
                (TPM2B_DIGEST*)&(target->keyedHash), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPM2B_DIGEST_Unmarshal(
                (TPM2B_DIGEST*)&(target->sym), buffer, size);
#  endif  // ALG_SYMCIPHER
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPM2B_PUBLIC_KEY_RSA_Unmarshal(
                (TPM2B_PUBLIC_KEY_RSA*)&(target->rsa), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPMS_ECC_POINT_Unmarshal(
                (TPMS_ECC_POINT*)&(target->ecc), buffer, size);
#  endif  // ALG_ECC
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_PUBLIC_ID_Marshal(
    TPMU_PUBLIC_ID* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPM2B_DIGEST_Marshal(
                (TPM2B_DIGEST*)&(source->keyedHash), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPM2B_DIGEST_Marshal((TPM2B_DIGEST*)&(source->sym), buffer, size);
#  endif  // ALG_SYMCIPHER
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPM2B_PUBLIC_KEY_RSA_Marshal(
                (TPM2B_PUBLIC_KEY_RSA*)&(source->rsa), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPMS_ECC_POINT_Marshal(
                (TPMS_ECC_POINT*)&(source->ecc), buffer, size);
#  endif  // ALG_ECC
    }
    return 0;
}

// Table "Definition of TPMS_KEYEDHASH_PARMS Structure" (Part 2: Structures)
TPM_RC
TPMS_KEYEDHASH_PARMS_Unmarshal(
    TPMS_KEYEDHASH_PARMS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMT_KEYEDHASH_SCHEME_Unmarshal(
        (TPMT_KEYEDHASH_SCHEME*)&(target->scheme), buffer, size, 1);
    return result;
}
UINT16
TPMS_KEYEDHASH_PARMS_Marshal(TPMS_KEYEDHASH_PARMS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMT_KEYEDHASH_SCHEME_Marshal(
                          (TPMT_KEYEDHASH_SCHEME*)&(source->scheme), buffer, size));
    return result;
}

////////////////////////////////////////////////////////////////////////////////
//                       ########   ######     ###
//                       ##     ## ##    ##   ## ##
//                       ##     ## ##        ##   ##
//                       ########   ######  ##     ##
//                       ##   ##         ## #########
//                       ##    ##  ##    ## ##     ##
//                       ##     ##  ######  ##     ##
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMS_RSA_PARMS Structure" (Part 2: Structures)
#  if ALG_RSA
TPM_RC
TPMS_RSA_PARMS_Unmarshal(TPMS_RSA_PARMS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMT_SYM_DEF_OBJECT_Unmarshal(
        (TPMT_SYM_DEF_OBJECT*)&(target->symmetric), buffer, size, 1);
    if(result == TPM_RC_SUCCESS)
        result = TPMT_RSA_SCHEME_Unmarshal(
            (TPMT_RSA_SCHEME*)&(target->scheme), buffer, size, 1);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RSA_KEY_BITS_Unmarshal(
            (TPMI_RSA_KEY_BITS*)&(target->keyBits), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT32_Unmarshal((UINT32*)&(target->exponent), buffer, size);
    return result;
}
UINT16
TPMS_RSA_PARMS_Marshal(TPMS_RSA_PARMS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMT_SYM_DEF_OBJECT_Marshal(
                          (TPMT_SYM_DEF_OBJECT*)&(source->symmetric), buffer, size));
    result        = (UINT16)(result
                      + TPMT_RSA_SCHEME_Marshal(
                          (TPMT_RSA_SCHEME*)&(source->scheme), buffer, size));
    result        = (UINT16)(result
                      + TPMI_RSA_KEY_BITS_Marshal(
                          (TPMI_RSA_KEY_BITS*)&(source->keyBits), buffer, size));
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->exponent), buffer, size));
    return result;
}
#  endif  // ALG_RSA

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Table "Definition of TPMS_ECC_PARMS Structure" (Part 2: Structures)
#  if ALG_ECC
TPM_RC
TPMS_ECC_PARMS_Unmarshal(TPMS_ECC_PARMS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMT_SYM_DEF_OBJECT_Unmarshal(
        (TPMT_SYM_DEF_OBJECT*)&(target->symmetric), buffer, size, 1);
    if(result == TPM_RC_SUCCESS)
        result = TPMT_ECC_SCHEME_Unmarshal(
            (TPMT_ECC_SCHEME*)&(target->scheme), buffer, size, 1);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_ECC_CURVE_Unmarshal(
            (TPMI_ECC_CURVE*)&(target->curveID), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = TPMT_KDF_SCHEME_Unmarshal(
            (TPMT_KDF_SCHEME*)&(target->kdf), buffer, size, 1);
    return result;
}
UINT16
TPMS_ECC_PARMS_Marshal(TPMS_ECC_PARMS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMT_SYM_DEF_OBJECT_Marshal(
                          (TPMT_SYM_DEF_OBJECT*)&(source->symmetric), buffer, size));
    result        = (UINT16)(result
                      + TPMT_ECC_SCHEME_Marshal(
                          (TPMT_ECC_SCHEME*)&(source->scheme), buffer, size));
    result        = (UINT16)(result
                      + TPMI_ECC_CURVE_Marshal(
                          (TPMI_ECC_CURVE*)&(source->curveID), buffer, size));
    result        = (UINT16)(result
                      + TPMT_KDF_SCHEME_Marshal(
                          (TPMT_KDF_SCHEME*)&(source->kdf), buffer, size));
    return result;
}
#  endif  // ALG_ECC

// Table "Definition of TPMU_PUBLIC_PARMS Union" (Part 2: Structures)
TPM_RC
TPMU_PUBLIC_PARMS_Unmarshal(
    TPMU_PUBLIC_PARMS* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPMS_KEYEDHASH_PARMS_Unmarshal(
                (TPMS_KEYEDHASH_PARMS*)&(target->keyedHashDetail), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPMS_SYMCIPHER_PARMS_Unmarshal(
                (TPMS_SYMCIPHER_PARMS*)&(target->symDetail), buffer, size);
#  endif  // ALG_SYMCIPHER
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPMS_RSA_PARMS_Unmarshal(
                (TPMS_RSA_PARMS*)&(target->rsaDetail), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPMS_ECC_PARMS_Unmarshal(
                (TPMS_ECC_PARMS*)&(target->eccDetail), buffer, size);
#  endif  // ALG_ECC
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_PUBLIC_PARMS_Marshal(
    TPMU_PUBLIC_PARMS* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPMS_KEYEDHASH_PARMS_Marshal(
                (TPMS_KEYEDHASH_PARMS*)&(source->keyedHashDetail), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPMS_SYMCIPHER_PARMS_Marshal(
                (TPMS_SYMCIPHER_PARMS*)&(source->symDetail), buffer, size);
#  endif  // ALG_SYMCIPHER
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPMS_RSA_PARMS_Marshal(
                (TPMS_RSA_PARMS*)&(source->rsaDetail), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPMS_ECC_PARMS_Marshal(
                (TPMS_ECC_PARMS*)&(source->eccDetail), buffer, size);
#  endif  // ALG_ECC
    }
    return 0;
}

// Table "Definition of TPMT_PUBLIC_PARMS Structure" (Part 2: Structures)
TPM_RC
TPMT_PUBLIC_PARMS_Unmarshal(TPMT_PUBLIC_PARMS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPMI_ALG_PUBLIC_Unmarshal((TPMI_ALG_PUBLIC*)&(target->type), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPMU_PUBLIC_PARMS_Unmarshal((TPMU_PUBLIC_PARMS*)&(target->parameters),
                                        buffer,
                                        size,
                                        (UINT32)target->type);
    return result;
}
UINT16
TPMT_PUBLIC_PARMS_Marshal(TPMT_PUBLIC_PARMS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_PUBLIC_Marshal(
                          (TPMI_ALG_PUBLIC*)&(source->type), buffer, size));
    result        = (UINT16)(result
                      + TPMU_PUBLIC_PARMS_Marshal(
                          (TPMU_PUBLIC_PARMS*)&(source->parameters),
                          buffer,
                          size,
                          (UINT32)source->type));
    return result;
}

// Table "Definition of TPMT_PUBLIC Structure" (Part 2: Structures)
TPM_RC
TPMT_PUBLIC_Unmarshal(TPMT_PUBLIC* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result =
        TPMI_ALG_PUBLIC_Unmarshal((TPMI_ALG_PUBLIC*)&(target->type), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_ALG_HASH_Unmarshal(
            (TPMI_ALG_HASH*)&(target->nameAlg), buffer, size, flag);
    if(result == TPM_RC_SUCCESS)
        result = TPMA_OBJECT_Unmarshal(
            (TPMA_OBJECT*)&(target->objectAttributes), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_DIGEST_Unmarshal(
            (TPM2B_DIGEST*)&(target->authPolicy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPMU_PUBLIC_PARMS_Unmarshal((TPMU_PUBLIC_PARMS*)&(target->parameters),
                                        buffer,
                                        size,
                                        (UINT32)target->type);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_PUBLIC_ID_Unmarshal(
            (TPMU_PUBLIC_ID*)&(target->unique), buffer, size, (UINT32)target->type);
    return result;
}
UINT16
TPMT_PUBLIC_Marshal(TPMT_PUBLIC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_PUBLIC_Marshal(
                          (TPMI_ALG_PUBLIC*)&(source->type), buffer, size));
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->nameAlg), buffer, size));
    result        = (UINT16)(result
                      + TPMA_OBJECT_Marshal(
                          (TPMA_OBJECT*)&(source->objectAttributes), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->authPolicy), buffer, size));
    result        = (UINT16)(result
                      + TPMU_PUBLIC_PARMS_Marshal(
                          (TPMU_PUBLIC_PARMS*)&(source->parameters),
                          buffer,
                          size,
                          (UINT32)source->type));
    result        = (UINT16)(result
                      + TPMU_PUBLIC_ID_Marshal((TPMU_PUBLIC_ID*)&(source->unique),
                                               buffer,
                                               size,
                                               (UINT32)source->type));
    return result;
}

// Table "Definition of TPM2B_PUBLIC Structure" (Part 2: Structures)
TPM_RC
TPM2B_PUBLIC_Unmarshal(TPM2B_PUBLIC* target, BYTE** buffer, INT32* size, BOOL flag)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMT_PUBLIC_Unmarshal(
                (TPMT_PUBLIC*)&(target->publicArea), buffer, size, flag);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}
UINT16
TPM2B_PUBLIC_Marshal(TPM2B_PUBLIC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result = (UINT16)(result
                      + TPMT_PUBLIC_Marshal(
                          (TPMT_PUBLIC*)&(source->publicArea), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPM2B_TEMPLATE Structure" (Part 2: Structures)
TPM_RC
TPM2B_TEMPLATE_Unmarshal(TPM2B_TEMPLATE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMT_PUBLIC)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_TEMPLATE_Marshal(TPM2B_TEMPLATE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_PRIVATE_VENDOR_SPECIFIC Structure" (Part 2: Structures)
TPM_RC
TPM2B_PRIVATE_VENDOR_SPECIFIC_Unmarshal(
    TPM2B_PRIVATE_VENDOR_SPECIFIC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > PRIVATE_VENDOR_SPECIFIC_BYTES))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_PRIVATE_VENDOR_SPECIFIC_Marshal(
    TPM2B_PRIVATE_VENDOR_SPECIFIC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMU_SENSITIVE_COMPOSITE Union" (Part 2: Structures)
TPM_RC
TPMU_SENSITIVE_COMPOSITE_Unmarshal(
    TPMU_SENSITIVE_COMPOSITE* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPM2B_PRIVATE_KEY_RSA_Unmarshal(
                (TPM2B_PRIVATE_KEY_RSA*)&(target->rsa), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPM2B_ECC_PARAMETER_Unmarshal(
                (TPM2B_ECC_PARAMETER*)&(target->ecc), buffer, size);
#  endif  // ALG_ECC
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPM2B_SENSITIVE_DATA_Unmarshal(
                (TPM2B_SENSITIVE_DATA*)&(target->bits), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPM2B_SYM_KEY_Unmarshal(
                (TPM2B_SYM_KEY*)&(target->sym), buffer, size);
#  endif  // ALG_SYMCIPHER
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_SENSITIVE_COMPOSITE_Marshal(
    TPMU_SENSITIVE_COMPOSITE* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
#  if ALG_RSA
        case TPM_ALG_RSA:
            return TPM2B_PRIVATE_KEY_RSA_Marshal(
                (TPM2B_PRIVATE_KEY_RSA*)&(source->rsa), buffer, size);
#  endif  // ALG_RSA
#  if ALG_ECC
        case TPM_ALG_ECC:
            return TPM2B_ECC_PARAMETER_Marshal(
                (TPM2B_ECC_PARAMETER*)&(source->ecc), buffer, size);
#  endif  // ALG_ECC
#  if ALG_KEYEDHASH
        case TPM_ALG_KEYEDHASH:
            return TPM2B_SENSITIVE_DATA_Marshal(
                (TPM2B_SENSITIVE_DATA*)&(source->bits), buffer, size);
#  endif  // ALG_KEYEDHASH
#  if ALG_SYMCIPHER
        case TPM_ALG_SYMCIPHER:
            return TPM2B_SYM_KEY_Marshal(
                (TPM2B_SYM_KEY*)&(source->sym), buffer, size);
#  endif  // ALG_SYMCIPHER
    }
    return 0;
}

// Table "Definition of TPMT_SENSITIVE Structure" (Part 2: Structures)
TPM_RC
TPMT_SENSITIVE_Unmarshal(TPMT_SENSITIVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMI_ALG_PUBLIC_Unmarshal(
        (TPMI_ALG_PUBLIC*)&(target->sensitiveType), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_AUTH_Unmarshal((TPM2B_AUTH*)&(target->authValue), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result =
            TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->seedValue), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_SENSITIVE_COMPOSITE_Unmarshal(
            (TPMU_SENSITIVE_COMPOSITE*)&(target->sensitive),
            buffer,
            size,
            (UINT32)target->sensitiveType);
    return result;
}
UINT16
TPMT_SENSITIVE_Marshal(TPMT_SENSITIVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_ALG_PUBLIC_Marshal(
                          (TPMI_ALG_PUBLIC*)&(source->sensitiveType), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_AUTH_Marshal(
                          (TPM2B_AUTH*)&(source->authValue), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->seedValue), buffer, size));
    result        = (UINT16)(result
                      + TPMU_SENSITIVE_COMPOSITE_Marshal(
                          (TPMU_SENSITIVE_COMPOSITE*)&(source->sensitive),
                          buffer,
                          size,
                          (UINT32)source->sensitiveType));
    return result;
}

// Table "Definition of TPM2B_SENSITIVE Structure" (Part 2: Structures)
TPM_RC
TPM2B_SENSITIVE_Unmarshal(TPM2B_SENSITIVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    // if there was an error or if target->size equal to 0,
    // skip unmarshaling of the structure
    if((result == TPM_RC_SUCCESS) && (target->size != 0))
    {
        INT32 startSize = *size;
        result          = TPMT_SENSITIVE_Unmarshal(
            (TPMT_SENSITIVE*)&(target->sensitiveArea), buffer, size);
        if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
            result = TPM_RC_SIZE;
    }
    return result;
}
UINT16
TPM2B_SENSITIVE_Marshal(TPM2B_SENSITIVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result = (UINT16)(result
                      + TPMT_SENSITIVE_Marshal(
                          (TPMT_SENSITIVE*)&(source->sensitiveArea), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPM2B_PRIVATE Structure" (Part 2: Structures)
TPM_RC
TPM2B_PRIVATE_Unmarshal(TPM2B_PRIVATE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(_PRIVATE)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_PRIVATE_Marshal(TPM2B_PRIVATE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPM2B_ID_OBJECT Structure" (Part 2: Structures)
TPM_RC
TPM2B_ID_OBJECT_Unmarshal(TPM2B_ID_OBJECT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMS_ID_OBJECT)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.credential), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_ID_OBJECT_Marshal(TPM2B_ID_OBJECT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.credential),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_NV_PIN_COUNTER_PARAMETERS Structure" (Part 2: Structures)
TPM_RC
TPMS_NV_PIN_COUNTER_PARAMETERS_Unmarshal(
    TPMS_NV_PIN_COUNTER_PARAMETERS* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)&(target->pinCount), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT32_Unmarshal((UINT32*)&(target->pinLimit), buffer, size);
    return result;
}
UINT16
TPMS_NV_PIN_COUNTER_PARAMETERS_Marshal(
    TPMS_NV_PIN_COUNTER_PARAMETERS* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->pinCount), buffer, size));
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->pinLimit), buffer, size));
    return result;
}

// Table "Definition of TPMA_NV Bits" (Part 2: Structures)
TPM_RC
TPMA_NV_Unmarshal(TPMA_NV* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT32*)target) & (UINT32)0x01f00300)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMA_NV_EXP Bits" (Part 2: Structures)
TPM_RC
TPMA_NV_EXP_Unmarshal(TPMA_NV_EXP* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT64_Unmarshal((UINT64*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // check that no reserved bits are set
        if(*((UINT64*)target) & (UINT64)0xfffffff801f00300)
            result = TPM_RC_RESERVED_BITS;
    }
    return result;
}
// Table "Definition of TPMS_NV_PUBLIC Structure" (Part 2: Structures)
TPM_RC
TPMS_NV_PUBLIC_Unmarshal(TPMS_NV_PUBLIC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMI_RH_NV_LEGACY_INDEX_Unmarshal(
        (TPMI_RH_NV_LEGACY_INDEX*)&(target->nvIndex), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_ALG_HASH_Unmarshal(
            (TPMI_ALG_HASH*)&(target->nameAlg), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result = TPMA_NV_Unmarshal((TPMA_NV*)&(target->attributes), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_DIGEST_Unmarshal(
            (TPM2B_DIGEST*)&(target->authPolicy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT16_Unmarshal((UINT16*)&(target->dataSize), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->dataSize > MAX_NV_INDEX_SIZE))
        result = TPM_RC_SIZE;
    return result;
}
UINT16
TPMS_NV_PUBLIC_Marshal(TPMS_NV_PUBLIC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result
                 + TPMI_RH_NV_LEGACY_INDEX_Marshal(
                     (TPMI_RH_NV_LEGACY_INDEX*)&(source->nvIndex), buffer, size));
    result = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->nameAlg), buffer, size));
    result =
        (UINT16)(result
                 + TPMA_NV_Marshal((TPMA_NV*)&(source->attributes), buffer, size));
    result = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->authPolicy), buffer, size));
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->dataSize), buffer, size));
    return result;
}

// Table "Definition of TPM2B_NV_PUBLIC Structure" (Part 2: Structures)
TPM_RC
TPM2B_NV_PUBLIC_Unmarshal(TPM2B_NV_PUBLIC* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMS_NV_PUBLIC_Unmarshal(
                (TPMS_NV_PUBLIC*)&(target->nvPublic), buffer, size);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}
UINT16
TPM2B_NV_PUBLIC_Marshal(TPM2B_NV_PUBLIC* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result = (UINT16)(result
                      + TPMS_NV_PUBLIC_Marshal(
                          (TPMS_NV_PUBLIC*)&(source->nvPublic), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPMS_NV_PUBLIC_EXP_ATTR Structure" (Part 2: Structures)
TPM_RC
TPMS_NV_PUBLIC_EXP_ATTR_Unmarshal(
    TPMS_NV_PUBLIC_EXP_ATTR* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPMI_RH_NV_EXP_INDEX_Unmarshal(
        (TPMI_RH_NV_EXP_INDEX*)&(target->nvIndex), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_ALG_HASH_Unmarshal(
            (TPMI_ALG_HASH*)&(target->nameAlg), buffer, size, 0);
    if(result == TPM_RC_SUCCESS)
        result =
            TPMA_NV_EXP_Unmarshal((TPMA_NV_EXP*)&(target->attributes), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_DIGEST_Unmarshal(
            (TPM2B_DIGEST*)&(target->authPolicy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = UINT16_Unmarshal((UINT16*)&(target->dataSize), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->dataSize > MAX_NV_INDEX_SIZE))
        result = TPM_RC_SIZE;
    return result;
}
UINT16
TPMS_NV_PUBLIC_EXP_ATTR_Marshal(
    TPMS_NV_PUBLIC_EXP_ATTR* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPMI_RH_NV_EXP_INDEX_Marshal(
                          (TPMI_RH_NV_EXP_INDEX*)&(source->nvIndex), buffer, size));
    result        = (UINT16)(result
                      + TPMI_ALG_HASH_Marshal(
                          (TPMI_ALG_HASH*)&(source->nameAlg), buffer, size));
    result        = (UINT16)(result
                      + TPMA_NV_EXP_Marshal(
                          (TPMA_NV_EXP*)&(source->attributes), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->authPolicy), buffer, size));
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->dataSize), buffer, size));
    return result;
}

// Table "Definition of TPMU_NV_PUBLIC_2 Union" (Part 2: Structures)
TPM_RC
TPMU_NV_PUBLIC_2_Unmarshal(
    TPMU_NV_PUBLIC_2* target, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
        case TPM_HT_NV_INDEX:
            return TPMS_NV_PUBLIC_Unmarshal(
                (TPMS_NV_PUBLIC*)&(target->nvIndex), buffer, size);
        case TPM_HT_EXTERNAL_NV:
            return TPMS_NV_PUBLIC_EXP_ATTR_Unmarshal(
                (TPMS_NV_PUBLIC_EXP_ATTR*)&(target->externalNV), buffer, size);
        case TPM_HT_PERMANENT_NV:
            return TPMS_NV_PUBLIC_Unmarshal(
                (TPMS_NV_PUBLIC*)&(target->permanentNV), buffer, size);
    }
    return TPM_RC_SELECTOR;
}
UINT16
TPMU_NV_PUBLIC_2_Marshal(
    TPMU_NV_PUBLIC_2* source, BYTE** buffer, INT32* size, UINT32 selector)
{
    switch(selector)
    {
        case TPM_HT_NV_INDEX:
            return TPMS_NV_PUBLIC_Marshal(
                (TPMS_NV_PUBLIC*)&(source->nvIndex), buffer, size);
        case TPM_HT_EXTERNAL_NV:
            return TPMS_NV_PUBLIC_EXP_ATTR_Marshal(
                (TPMS_NV_PUBLIC_EXP_ATTR*)&(source->externalNV), buffer, size);
        case TPM_HT_PERMANENT_NV:
            return TPMS_NV_PUBLIC_Marshal(
                (TPMS_NV_PUBLIC*)&(source->permanentNV), buffer, size);
    }
    return 0;
}

// Table "Definition of TPMT_NV_PUBLIC_2 Structure" (Part 2: Structures)
TPM_RC
TPMT_NV_PUBLIC_2_Unmarshal(TPMT_NV_PUBLIC_2* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = TPM_HT_Unmarshal((TPM_HT*)&(target->handleType), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMU_NV_PUBLIC_2_Unmarshal((TPMU_NV_PUBLIC_2*)&(target->nvPublic2),
                                            buffer,
                                            size,
                                            (UINT32)target->handleType);
    return result;
}
UINT16
TPMT_NV_PUBLIC_2_Marshal(TPMT_NV_PUBLIC_2* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM_HT_Marshal((TPM_HT*)&(source->handleType), buffer, size));
    result =
        (UINT16)(result
                 + TPMU_NV_PUBLIC_2_Marshal((TPMU_NV_PUBLIC_2*)&(source->nvPublic2),
                                            buffer,
                                            size,
                                            (UINT32)source->handleType));
    return result;
}

// Table "Definition of TPM2B_NV_PUBLIC_2 Structure" (Part 2: Structures)
TPM_RC
TPM2B_NV_PUBLIC_2_Unmarshal(TPM2B_NV_PUBLIC_2* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->size), buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        // if size is zero, then the required structure is missing
        if(target->size == 0)
            result = TPM_RC_SIZE;
        else
        {
            INT32 startSize = *size;
            result          = TPMT_NV_PUBLIC_2_Unmarshal(
                (TPMT_NV_PUBLIC_2*)&(target->nvPublic2), buffer, size);
            if((result == TPM_RC_SUCCESS) && (target->size != (startSize - *size)))
                result = TPM_RC_SIZE;
        }
    }
    return result;
}
UINT16
TPM2B_NV_PUBLIC_2_Marshal(TPM2B_NV_PUBLIC_2* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result = (UINT16)(result
                      + TPMT_NV_PUBLIC_2_Marshal(
                          (TPMT_NV_PUBLIC_2*)&(source->nvPublic2), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPM2B_CONTEXT_SENSITIVE Structure" (Part 2: Structures)
TPM_RC
TPM2B_CONTEXT_SENSITIVE_Unmarshal(
    TPM2B_CONTEXT_SENSITIVE* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > MAX_CONTEXT_SIZE))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_CONTEXT_SENSITIVE_Marshal(
    TPM2B_CONTEXT_SENSITIVE* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_CONTEXT_DATA Structure" (Part 2: Structures)
TPM_RC
TPMS_CONTEXT_DATA_Unmarshal(TPMS_CONTEXT_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result =
        TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST*)&(target->integrity), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_CONTEXT_SENSITIVE_Unmarshal(
            (TPM2B_CONTEXT_SENSITIVE*)&(target->encrypted), buffer, size);
    return result;
}
UINT16
TPMS_CONTEXT_DATA_Marshal(TPMS_CONTEXT_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->integrity), buffer, size));
    result =
        (UINT16)(result
                 + TPM2B_CONTEXT_SENSITIVE_Marshal(
                     (TPM2B_CONTEXT_SENSITIVE*)&(source->encrypted), buffer, size));
    return result;
}

// Table "Definition of TPM2B_CONTEXT_DATA Structure" (Part 2: Structures)
TPM_RC
TPM2B_CONTEXT_DATA_Unmarshal(TPM2B_CONTEXT_DATA* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT16_Unmarshal((UINT16*)&(target->t.size), buffer, size);
    if((result == TPM_RC_SUCCESS) && (target->t.size > sizeof(TPMS_CONTEXT_DATA)))
        result = TPM_RC_SIZE;
    if(result == TPM_RC_SUCCESS)
        result = BYTE_Array_Unmarshal(
            (BYTE*)&(target->t.buffer), buffer, size, (INT32)target->t.size);
    return result;
}
UINT16
TPM2B_CONTEXT_DATA_Marshal(TPM2B_CONTEXT_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT16_Marshal((UINT16*)&(source->t.size), buffer, size));
    // if size equal to 0, the rest of the structure is a zero buffer
    if(source->t.size == 0)
        return result;
    result = (UINT16)(result
                      + BYTE_Array_Marshal((BYTE*)&(source->t.buffer),
                                           buffer,
                                           size,
                                           (INT32)source->t.size));
    return result;
}

// Table "Definition of TPMS_CONTEXT Structure" (Part 2: Structures)
TPM_RC
TPMS_CONTEXT_Unmarshal(TPMS_CONTEXT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT64_Unmarshal((UINT64*)&(target->sequence), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_DH_SAVED_Unmarshal(
            (TPMI_DH_SAVED*)&(target->savedHandle), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPMI_RH_HIERARCHY_Unmarshal(
            (TPMI_RH_HIERARCHY*)&(target->hierarchy), buffer, size);
    if(result == TPM_RC_SUCCESS)
        result = TPM2B_CONTEXT_DATA_Unmarshal(
            (TPM2B_CONTEXT_DATA*)&(target->contextBlob), buffer, size);
    return result;
}
UINT16
TPMS_CONTEXT_Marshal(TPMS_CONTEXT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT64_Marshal((UINT64*)&(source->sequence), buffer, size));
    result = (UINT16)(result
                      + TPMI_DH_SAVED_Marshal(
                          (TPMI_DH_SAVED*)&(source->savedHandle), buffer, size));
    result = (UINT16)(result
                      + TPMI_RH_HIERARCHY_Marshal(
                          (TPMI_RH_HIERARCHY*)&(source->hierarchy), buffer, size));
    result = (UINT16)(result
                      + TPM2B_CONTEXT_DATA_Marshal(
                          (TPM2B_CONTEXT_DATA*)&(source->contextBlob), buffer, size));
    return result;
}

// Table "Definition of TPMS_CREATION_DATA Structure" (Part 2: Structures)
UINT16
TPMS_CREATION_DATA_Marshal(TPMS_CREATION_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result        = (UINT16)(result
                      + TPML_PCR_SELECTION_Marshal(
                          (TPML_PCR_SELECTION*)&(source->pcrSelect), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DIGEST_Marshal(
                          (TPM2B_DIGEST*)&(source->pcrDigest), buffer, size));
    result        = (UINT16)(result
                      + TPMA_LOCALITY_Marshal(
                          (TPMA_LOCALITY*)&(source->locality), buffer, size));
    result        = (UINT16)(result
                      + TPM_ALG_ID_Marshal(
                          (TPM_ALG_ID*)&(source->parentNameAlg), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->parentName), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_NAME_Marshal(
                          (TPM2B_NAME*)&(source->parentQualifiedName), buffer, size));
    result        = (UINT16)(result
                      + TPM2B_DATA_Marshal(
                          (TPM2B_DATA*)&(source->outsideInfo), buffer, size));
    return result;
}

// Table "Definition of TPM2B_CREATION_DATA Structure" (Part 2: Structures)
UINT16
TPM2B_CREATION_DATA_Marshal(TPM2B_CREATION_DATA* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    // Marshal a dummy value of the 2B size. This makes sure that 'buffer'
    // and 'size' are advanced as necessary (i.e., if they are present)
    result = UINT16_Marshal(&result, buffer, size);
    // Marshal the structure
    result =
        (UINT16)(result
                 + TPMS_CREATION_DATA_Marshal(
                     (TPMS_CREATION_DATA*)&(source->creationData), buffer, size));
    // if a buffer was provided, go back and fill in the actual size
    if(buffer != NULL)
        UINT16_TO_BYTE_ARRAY((result - 2), (*buffer - result));
    return result;
}

// Table "Definition of TPM_AT Constants" (Part 2: Structures)
TPM_RC
TPM_AT_Unmarshal(TPM_AT* target, BYTE** buffer, INT32* size)
{
    TPM_RC result;
    result = UINT32_Unmarshal((UINT32*)target, buffer, size);
    if(result == TPM_RC_SUCCESS)
    {
        switch(*target)
        {
            case TPM_AT_ANY:
            case TPM_AT_ERROR:
            case TPM_AT_PV1:
            case TPM_AT_VEND:
                break;
            default:
                result = TPM_RC_VALUE;
                break;
        }
    }
    return result;
}
// Table "Definition of TPMS_AC_OUTPUT Structure" (Part 2: Structures)
UINT16
TPMS_AC_OUTPUT_Marshal(TPMS_AC_OUTPUT* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result = (UINT16)(result + TPM_AT_Marshal((TPM_AT*)&(source->tag), buffer, size));
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->data), buffer, size));
    return result;
}

// Table "Definition of TPML_AC_CAPABILITIES Structure" (Part 2: Structures)
UINT16
TPML_AC_CAPABILITIES_Marshal(TPML_AC_CAPABILITIES* source, BYTE** buffer, INT32* size)
{
    UINT16 result = 0;
    result =
        (UINT16)(result + UINT32_Marshal((UINT32*)&(source->count), buffer, size));
    result = (UINT16)(result
                      + TPMS_AC_OUTPUT_Array_Marshal(
                          (TPMS_AC_OUTPUT*)&(source->acCapabilities),
                          buffer,
                          size,
                          (INT32)source->count));
    return result;
}

// For structures that unmarshals/marshals an array, the code calls an
// un/marshaling function to process the array of the defined type.
// This section contains the functions that perform that operation
// Array Unmarshal/Marshal for BYTE
TPM_RC
BYTE_Array_Unmarshal(BYTE* target, BYTE** buffer, INT32* size, INT32 count)
{
    if(*size < count)
        return TPM_RC_INSUFFICIENT;
    memcpy(target, *buffer, count);
    *size -= count;
    *buffer += count;
    return TPM_RC_SUCCESS;
}
UINT16
BYTE_Array_Marshal(BYTE* source, BYTE** buffer, INT32* size, INT32 count)
{
    // all TPM sizes are much less than UINT16 in size, but the marshalling
    // code uses INT32 (signed) to track underflow in size.  Any attempt to
    // marshal more than 0xFFFF is an obvious error.
    pAssert_ZERO(count < INT16_MAX);
    if(buffer != 0 && count < INT16_MAX)
    {
        if((size == 0) || ((*size -= count) >= 0))
        {
            memcpy(*buffer, source, count);
            *buffer += count;
        }
        pAssert_ZERO((size == 0) || (*size >= 0));
    }
    return ((UINT16)count);
}

// Array Unmarshal and Marshal for TPM_ALG_ID
TPM_RC
TPM_ALG_ID_Array_Unmarshal(
    TPM_ALG_ID* target, BYTE** buffer, INT32* size, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPM_ALG_ID_Unmarshal(&target[i], buffer, size);
    }
    return result;
}
UINT16
TPM_ALG_ID_Array_Marshal(TPM_ALG_ID* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM_ALG_ID_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Unmarshal and Marshal for TPM_CC
TPM_RC
TPM_CC_Array_Unmarshal(TPM_CC* target, BYTE** buffer, INT32* size, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPM_CC_Unmarshal(&target[i], buffer, size);
    }
    return result;
}
UINT16
TPM_CC_Array_Marshal(TPM_CC* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM_CC_Marshal(&source[i], buffer, size);
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////
//                        ########  ######   ######
//                        ##       ##    ## ##    ##
//                        ##       ##       ##
//                        ######   ##       ##
//                        ##       ##       ##
//                        ##       ##    ## ##    ##
//                        ########  ######   ######
////////////////////////////////////////////////////////////////////////////////
// Array Marshal for TPM_ECC_CURVE
#  if ALG_ECC
UINT16
TPM_ECC_CURVE_Array_Marshal(
    TPM_ECC_CURVE* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM_ECC_CURVE_Marshal(&source[i], buffer, size);
    }
    return result;
}
#  endif  // ALG_ECC

// Array Marshal for TPM_HANDLE
UINT16
TPM_HANDLE_Array_Marshal(TPM_HANDLE* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM_HANDLE_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Unmarshal and Marshal for TPM2B_DIGEST
TPM_RC
TPM2B_DIGEST_Array_Unmarshal(
    TPM2B_DIGEST* target, BYTE** buffer, INT32* size, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPM2B_DIGEST_Unmarshal(&target[i], buffer, size);
    }
    return result;
}
UINT16
TPM2B_DIGEST_Array_Marshal(
    TPM2B_DIGEST* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM2B_DIGEST_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Unmarshal and Marshal for TPM2B_VENDOR_PROPERTY
TPM_RC
TPM2B_VENDOR_PROPERTY_Array_Unmarshal(
    TPM2B_VENDOR_PROPERTY* target, BYTE** buffer, INT32* size, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPM2B_VENDOR_PROPERTY_Unmarshal(&target[i], buffer, size);
    }
    return result;
}
UINT16
TPM2B_VENDOR_PROPERTY_Array_Marshal(
    TPM2B_VENDOR_PROPERTY* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM2B_VENDOR_PROPERTY_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMA_CC
UINT16
TPMA_CC_Array_Marshal(TPMA_CC* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMA_CC_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_AC_OUTPUT
UINT16
TPMS_AC_OUTPUT_Array_Marshal(
    TPMS_AC_OUTPUT* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_AC_OUTPUT_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_ACT_DATA
UINT16
TPMS_ACT_DATA_Array_Marshal(
    TPMS_ACT_DATA* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_ACT_DATA_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_ALG_PROPERTY
UINT16
TPMS_ALG_PROPERTY_Array_Marshal(
    TPMS_ALG_PROPERTY* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_ALG_PROPERTY_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Unmarshal and Marshal for TPMS_PCR_SELECTION
TPM_RC
TPMS_PCR_SELECTION_Array_Unmarshal(
    TPMS_PCR_SELECTION* target, BYTE** buffer, INT32* size, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPMS_PCR_SELECTION_Unmarshal(&target[i], buffer, size);
    }
    return result;
}
UINT16
TPMS_PCR_SELECTION_Array_Marshal(
    TPMS_PCR_SELECTION* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_PCR_SELECTION_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_TAGGED_PCR_SELECT
UINT16
TPMS_TAGGED_PCR_SELECT_Array_Marshal(
    TPMS_TAGGED_PCR_SELECT* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_TAGGED_PCR_SELECT_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_TAGGED_POLICY
UINT16
TPMS_TAGGED_POLICY_Array_Marshal(
    TPMS_TAGGED_POLICY* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_TAGGED_POLICY_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_TAGGED_PROPERTY
UINT16
TPMS_TAGGED_PROPERTY_Array_Marshal(
    TPMS_TAGGED_PROPERTY* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_TAGGED_PROPERTY_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Unmarshal and Marshal for TPMT_HA
TPM_RC
TPMT_HA_Array_Unmarshal(
    TPMT_HA* target, BYTE** buffer, INT32* size, BOOL flag, INT32 count)
{
    TPM_RC result = TPM_RC_SUCCESS;
    INT32  i;
    for(i = 0; ((result == TPM_RC_SUCCESS) && (i < count)); i++)
    {
        result = TPMT_HA_Unmarshal(&target[i], buffer, size, flag);
    }
    return result;
}
UINT16
TPMT_HA_Array_Marshal(TPMT_HA* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMT_HA_Marshal(&source[i], buffer, size);
    }
    return result;
}

#  if SEC_CHANNEL_SUPPORT
// Array Marshal for TPM2B_PUBLIC
UINT16
TPM2B_PUBLIC_Array_Marshal(
    TPM2B_PUBLIC* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPM2B_PUBLIC_Marshal(&source[i], buffer, size);
    }
    return result;
}

// Array Marshal for TPMS_SPDM_SESSION_INFO
UINT16
TPMS_SPDM_SESSION_INFO_Array_Marshal(
    TPMS_SPDM_SESSION_INFO* source, BYTE** buffer, INT32* size, INT32 count)
{
    UINT16 result = 0;
    INT32  i;
    for(i = 0; i < count; i++)
    {
        result += TPMS_SPDM_SESSION_INFO_Marshal(&source[i], buffer, size);
    }
    return result;
}
#  endif  // SEC_CHANNEL_SUPPORT
#endif    // !TABLE_DRIVEN_MARSHAL
